var documenterSearchIndex = {"docs":
[{"location":"types/#Syntax-Types","page":"Syntax Types","title":"Syntax Types","text":"","category":"section"},{"location":"types/","page":"Syntax Types","title":"Syntax Types","text":"Convenient types for storing analysis results of a given Julia Expr, or for creating certain Julia objects easily. These types define some common syntax one would manipulate in Julia meta programming.","category":"page"},{"location":"types/","page":"Syntax Types","title":"Syntax Types","text":"JLFunction\nJLStruct\nJLKwStruct\nJLIfElse\nJLMatch\nJLFor\nJLField\nJLKwField\nNoDefault\nno_default\nJLExpr","category":"page"},{"location":"types/#Expronicon.JLFunction","page":"Syntax Types","title":"Expronicon.JLFunction","text":"JLFunction <: JLExpr\n\nType describes a Julia function declaration expression.\n\nExample\n\nConstruct a function expression\n\njulia> JLFunction(;name=:foo, args=[:(x::T)], body= quote 1+1 end, head=:function, whereparams=[:T])\nfunction foo(x::T) where {T}\n    #= REPL[25]:1 =#    \n    1 + 1    \nend\n\nDecompose a function expression\n\njulia> ex = :(function foo(x::T) where {T}\n           #= REPL[25]:1 =#    \n           1 + 1    \n       end)\n:(function foo(x::T) where T\n      #= REPL[26]:1 =#\n      #= REPL[26]:3 =#\n      1 + 1\n  end)\n\njulia> jl = JLFunction(ex)\nfunction foo(x::T) where {T}\n    #= REPL[26]:1 =#    \n    #= REPL[26]:3 =#    \n    1 + 1    \nend\n\nGenerate Expr from JLFunction\n\njulia> codegen_ast(jl)\n:(function foo(x::T) where T\n      #= REPL[26]:1 =#\n      #= REPL[26]:3 =#\n      1 + 1\n  end)\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.JLStruct","page":"Syntax Types","title":"Expronicon.JLStruct","text":"JLStruct <: JLExpr\n\nType describes a Julia struct.\n\nExample\n\nConstruct a Julia struct.\n\njulia> JLStruct(;name=:Foo, typevars=[:T], fields=[JLField(;name=:x, type=Int)])\nstruct Foo{T}\n    x::Int64\nend\n\nDecompose a Julia struct expression\n\njulia> ex = :(struct Foo{T}\n           x::Int64\n       end)\n:(struct Foo{T}\n      #= REPL[31]:2 =#\n      x::Int64\n  end)\n\njulia> jl = JLStruct(ex)\nstruct Foo{T}\n    #= REPL[31]:2 =#\n    x::Int64\nend\n\nGenerate a Julia struct expression\n\njulia> codegen_ast(jl)\n:(struct Foo{T}\n      #= REPL[31]:2 =#\n      x::Int64\n  end)\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.JLKwStruct","page":"Syntax Types","title":"Expronicon.JLKwStruct","text":"JLKwStruct <: JLExpr\n\nType describes a Julia struct that allows keyword definition of defaults.\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.JLIfElse","page":"Syntax Types","title":"Expronicon.JLIfElse","text":"JLIfElse <: JLExpr\n\nJLIfElse describes a Julia if ... elseif ... else ... end expression. It allows one to easily construct such expression by inserting condition and code block via a map.\n\nExample\n\nConstruct JLIfElse object\n\nOne can construct an ifelse as following\n\njulia> jl = JLIfElse()\nnothing\n\njulia> jl.map[:(foo(x))] = :(x = 1 + 1)\n:(x = 1 + 1)\n\njulia> jl.map[:(goo(x))] = :(y = 1 + 2)\n:(y = 1 + 2)\n\njulia> jl.otherwise = :(error(\"abc\"))\n:(error(\"abc\"))\n\njulia> jl\nif foo(x)\n    x = 1 + 1\nelseif goo(x)\n    y = 1 + 2\nelse\n    error(\"abc\")\nend\n\nGenerate the Julia Expr object\n\nto generate the corresponding Expr object, one can call codegen_ast.\n\njulia> codegen_ast(jl)\n:(if foo(x)\n      x = 1 + 1\n  elseif goo(x)\n      y = 1 + 2\n  else\n      error(\"abc\")\n  end)\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.JLMatch","page":"Syntax Types","title":"Expronicon.JLMatch","text":"JLMatch <: JLExpr\n\nJLMatch describes a Julia pattern match expression defined by MLStyle. It allows one to construct such expression by simply assign each code block to the corresponding pattern expression.\n\nExample\n\nOne can construct a MLStyle pattern matching expression easily by assigning the corresponding pattern and its result to the map field.\n\njulia> jl = JLMatch(:x)\n#= line 0 =#\nnothing\n\njulia> jl = JLMatch(:x)\n#= line 0 =#\nnothing\n\njulia> jl.map[1] = true\ntrue\n\njulia> jl.map[2] = :(sin(x))\n:(sin(x))\n\njulia> jl\n#= line 0 =#\n@match x begin\n    1 => true\n    2 => sin(x)\n    _ =>     nothing\nend\n\nto generate the corresponding Julia Expr object, one can call codegen_ast.\n\njulia> codegen_ast(jl)\n:(let\n      true\n      var\"##return#263\" = nothing\n      var\"##265\" = x\n      if var\"##265\" isa Int64\n          #= line 0 =#\n          if var\"##265\" === 1\n              var\"##return#263\" = let\n                      true\n                  end\n              #= unused:1 =# @goto var\"####final#264#266\"\n          end\n          #= line 0 =#\n          if var\"##265\" === 2\n              var\"##return#263\" = let\n                      sin(x)\n                  end\n              #= unused:1 =# @goto var\"####final#264#266\"\n          end\n      end\n      #= line 0 =#\n      begin\n          var\"##return#263\" = let\n                  nothing\n              end\n          #= unused:1 =# @goto var\"####final#264#266\"\n      end\n      (error)(\"matching non-exhaustive, at #= line 0 =#\")\n      #= unused:1 =# @label var\"####final#264#266\"\n      var\"##return#263\"\n  end)\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.JLFor","page":"Syntax Types","title":"Expronicon.JLFor","text":"JLFor <: JLExpr\n\nSyntax type for Julia for loop.\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.JLField","page":"Syntax Types","title":"Expronicon.JLField","text":"JLField <: JLExpr\nJLField(name, type, line)\n\nType describes a Julia field in a Julia struct.\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.JLKwField","page":"Syntax Types","title":"Expronicon.JLKwField","text":"JLKwField <: JLExpr\nJLKwField(name, type, line, default=no_default)\n\nType describes a Julia field that can have a default value in a Julia struct.\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.NoDefault","page":"Syntax Types","title":"Expronicon.NoDefault","text":"NoDefault\n\nType describes a field should have no default value.\n\n\n\n\n\n","category":"type"},{"location":"types/#Expronicon.no_default","page":"Syntax Types","title":"Expronicon.no_default","text":"const no_default = NoDefault()\n\nConstant instance for NoDefault that describes a field should have no default value.\n\n\n\n\n\n","category":"constant"},{"location":"types/#Expronicon.JLExpr","page":"Syntax Types","title":"Expronicon.JLExpr","text":"abstract type JLExpr end\n\nAbstract type for Julia syntax type.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/#What-is-meta-programming?","page":"Tutorial","title":"What is meta programming?","text":"","category":"section"},{"location":"tutorials/#Analysis-Julia-expressions","page":"Tutorial","title":"Analysis Julia expressions","text":"","category":"section"},{"location":"tutorials/#Extract-function-name-of-a-simple-Julia-function","page":"Tutorial","title":"Extract function name of a simple Julia function","text":"","category":"section"},{"location":"tutorials/#Extract-conditions-of-an-ifelse-expression","page":"Tutorial","title":"Extract conditions of an ifelse expression","text":"","category":"section"},{"location":"tutorials/#Extract-loop-head","page":"Tutorial","title":"Extract loop head","text":"","category":"section"},{"location":"tutorials/#Transform-Julia-expressions","page":"Tutorial","title":"Transform Julia expressions","text":"","category":"section"},{"location":"tutorials/#Remove-LineNumberNode","page":"Tutorial","title":"Remove LineNumberNode","text":"","category":"section"},{"location":"tutorials/#Flatten-code-block-nodes","page":"Tutorial","title":"Flatten code block nodes","text":"","category":"section"},{"location":"tutorials/#Generate-Julia-expressions","page":"Tutorial","title":"Generate Julia expressions","text":"","category":"section"},{"location":"tutorials/#Generate-a-Julia-function","page":"Tutorial","title":"Generate a Julia function","text":"","category":"section"},{"location":"tutorials/#Generate-a-Julia-struct","page":"Tutorial","title":"Generate a Julia struct","text":"","category":"section"},{"location":"tutorials/#Generate-a-Julia-ifelse","page":"Tutorial","title":"Generate a Julia ifelse","text":"","category":"section"},{"location":"transform/#Transform","page":"Transform","title":"Transform","text":"","category":"section"},{"location":"transform/","page":"Transform","title":"Transform","text":"Some common transformations for Julia Expr, these functions takes an Expr and returns an Expr.","category":"page"},{"location":"transform/","page":"Transform","title":"Transform","text":"Modules = [Expronicon]\nPages = [\"transform.jl\"]","category":"page"},{"location":"transform/#Expronicon.eval_interp-Tuple{Module, Any}","page":"Transform","title":"Expronicon.eval_interp","text":"eval_interp(m::Module, ex)\n\nevaluate the interpolation operator in ex inside given module m.\n\n\n\n\n\n","category":"method"},{"location":"transform/#Expronicon.eval_literal-Tuple{Module, Any}","page":"Transform","title":"Expronicon.eval_literal","text":"eval_literal(m::Module, ex)\n\nEvaluate the literal values and insert them back to the expression. The literal value can be checked via is_literal.\n\n\n\n\n\n","category":"method"},{"location":"transform/#Expronicon.flatten_blocks-Tuple{Any}","page":"Transform","title":"Expronicon.flatten_blocks","text":"flatten_blocks(ex)\n\nRemove hierachical expression blocks.\n\n\n\n\n\n","category":"method"},{"location":"transform/#Expronicon.name_only-Tuple{Any}","page":"Transform","title":"Expronicon.name_only","text":"name_only(ex)\n\nRemove everything else leaving just names, currently supports function calls, type with type variables, subtype operator <: and type annotation ::.\n\nExample\n\njulia> using Expronicon\n\njulia> name_only(:(sin(2)))\n:sin\n\njulia> name_only(:(Foo{Int}))\n:Foo\n\njulia> name_only(:(Foo{Int} <: Real))\n:Foo\n\njulia> name_only(:(x::Int))\n:x\n\n\n\n\n\n","category":"method"},{"location":"transform/#Expronicon.prettify-Tuple{Any}","page":"Transform","title":"Expronicon.prettify","text":"prettify(ex)\n\nPrettify given expression, remove all LineNumberNode and extra code blocks.\n\ntips: Tips\nthe LineNumberNode inside macro calls won't be removed since the macrocall expression requires a LineNumberNode. See also issues/#9.\n\n\n\n\n\n","category":"method"},{"location":"transform/#Expronicon.rm_annotations-Tuple{Any}","page":"Transform","title":"Expronicon.rm_annotations","text":"rm_annotations(x)\n\nRemove type annotation of given expression.\n\n\n\n\n\n","category":"method"},{"location":"transform/#Expronicon.rm_lineinfo-Tuple{Any}","page":"Transform","title":"Expronicon.rm_lineinfo","text":"rm_lineinfo(ex)\n\nRemove LineNumberNode in a given expression.\n\ntips: Tips\nthe LineNumberNode inside macro calls won't be removed since the macrocall expression requires a LineNumberNode. See also issues/#9.\n\n\n\n\n\n","category":"method"},{"location":"transform/#Expronicon.rm_nothing-Tuple{Any}","page":"Transform","title":"Expronicon.rm_nothing","text":"rm_nothing(ex)\n\nRemove the constant value nothing in given expression ex.\n\n\n\n\n\n","category":"method"},{"location":"transform/#Expronicon.subtitute-Tuple{Expr, Pair}","page":"Transform","title":"Expronicon.subtitute","text":"subtitute(ex::Expr, old=>new)\n\nSubtitute the old symbol old with new.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"analysis/","page":"Analysis","title":"Analysis","text":"Functions for analysing a given Julia Expr, e.g splitting Julia function/struct definitions etc.","category":"page"},{"location":"analysis/","page":"Analysis","title":"Analysis","text":"Modules = [Expronicon]\nPages = [\"analysis.jl\"]","category":"page"},{"location":"analysis/#Expronicon.JLFor-Tuple{Expr}","page":"Analysis","title":"Expronicon.JLFor","text":"JLFor(ex::Expr)\n\nCreate a JLFor from given Julia for loop expression.\n\nExample\n\njulia> ex = @expr for i in 1:10, j in 1:j\n           M[i, j] += 1\n       end\n:(for i = 1:10, j = 1:j\n      #= REPL[3]:2 =#\n      M[i, j] += 1\n  end)\n\njulia> jl = JLFor(ex)\nfor i in 1 : 10,\n    j in 1 : j\n    #= loop body =#\n    begin\n        #= REPL[3]:2 =#        \n        M[i, j] += 1        \n    end\nend\n\njulia> jl.vars\n2-element Vector{Any}:\n :i\n :j\n\njulia> jl.iterators\n2-element Vector{Any}:\n :(1:10)\n :(1:j)\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.JLFunction-Tuple{Expr}","page":"Analysis","title":"Expronicon.JLFunction","text":"JLFunction(ex::Expr)\n\nCreate a JLFunction object from a Julia function Expr.\n\nExample\n\njulia> JLFunction(:(f(x) = 2))\nf(x) = begin\n    #= REPL[37]:1 =#    \n    2    \nend\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.JLIfElse-Tuple{Expr}","page":"Analysis","title":"Expronicon.JLIfElse","text":"JLIfElse(ex::Expr)\n\nCreate a JLIfElse from given Julia ifelse Expr.\n\nExample\n\njulia> ex = :(if foo(x)\n             x = 1 + 1\n         elseif goo(x)\n             y = 1 + 2\n         else\n             error(\"abc\")\n         end)\n:(if foo(x)\n      #= REPL[41]:2 =#\n      x = 1 + 1\n  elseif #= REPL[41]:3 =# goo(x)\n      #= REPL[41]:4 =#\n      y = 1 + 2\n  else\n      #= REPL[41]:6 =#\n      error(\"abc\")\n  end)\n\njulia> JLIfElse(ex)\nif foo(x)\n    begin\n        #= REPL[41]:2 =#        \n        x = 1 + 1        \n    end\nelseif begin\n    #= REPL[41]:3 =#    \n    goo(x)    \nend\n    begin\n        #= REPL[41]:4 =#        \n        y = 1 + 2        \n    end\nelse\n    begin\n        #= REPL[41]:6 =#        \n        error(\"abc\")        \n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.JLKwStruct","page":"Analysis","title":"Expronicon.JLKwStruct","text":"JLKwStruct(ex::Expr, typealias=nothing)\n\nCreate a JLKwStruct from given Julia struct Expr, with an option to attach an alias to this type name.\n\nExample\n\njulia> JLKwStruct(:(struct Foo\n           x::Int = 1\n       end))\n#= kw =# struct Foo\n    #= REPL[39]:2 =#\n    x::Int = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"analysis/#Expronicon.JLStruct-Tuple{Expr}","page":"Analysis","title":"Expronicon.JLStruct","text":"JLStruct(ex::Expr)\n\nCreate a JLStruct object from a Julia struct Expr.\n\nExample\n\njulia> JLStruct(:(struct Foo\n           x::Int\n       end))\nstruct Foo\n    #= REPL[38]:2 =#\n    x::Int\nend\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.compare_expr-Tuple{Any, Any}","page":"Analysis","title":"Expronicon.compare_expr","text":"compare_expr(lhs, rhs)\n\nCompare two expression of type Expr or Symbol semantically, which:\n\nignore the detail value LineNumberNode in comparision\nignore the detailed name of typevars in Expr(:curly, ...) or Expr(:where, ...)\n\nThis gives a way to compare two Julia expression semantically which means although some details of the expression is different but they should produce the same lowered code.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.compare_vars-Tuple{Any, Any}","page":"Analysis","title":"Expronicon.compare_vars","text":"compare_vars(lhs, rhs)\n\nCompare two expression by assuming all Symbols are variables, thus their value doesn't matter, only where they are matters under this assumption. See also compare_expr.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.has_kwfn_constructor","page":"Analysis","title":"Expronicon.has_kwfn_constructor","text":"has_kwfn_constructor(def[, name = struct_name_plain(def)])\n\nCheck if the struct definition contains keyword function constructor of name. The constructor name to check by default is the plain constructor which does not infer any type variables and requires user to input all type variables. See also struct_name_plain.\n\n\n\n\n\n","category":"function"},{"location":"analysis/#Expronicon.has_plain_constructor","page":"Analysis","title":"Expronicon.has_plain_constructor","text":"has_plain_constructor(def, name = struct_name_plain(def))\n\nCheck if the struct definition contains the plain constructor of name. By default the name is the inferable name struct_name_plain.\n\nExample\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::Int\n    y::N\n\n    Foo{T, N}(x, y) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # true\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo(x, y) = new{typeof(x), typeof(y)}(x, y)\nend\n\nhas_plain_constructor(def) # false\n\nthe arguments must have no type annotations.\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo{T, N}(x::T, y::N) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # false\n\n\n\n\n\n","category":"function"},{"location":"analysis/#Expronicon.is_field-Tuple{Any}","page":"Analysis","title":"Expronicon.is_field","text":"is_field(ex)\n\nCheck if ex is a valid field expression.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.is_field_default-Tuple{Any}","page":"Analysis","title":"Expronicon.is_field_default","text":"is_field_default(ex)\n\nCheck if ex is a <field expr> = <default expr> expression.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.is_for-Tuple{Any}","page":"Analysis","title":"Expronicon.is_for","text":"is_for(ex)\n\nCheck if ex is a for loop expression.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.is_function-Tuple{Any}","page":"Analysis","title":"Expronicon.is_function","text":"is_function(def)\n\nCheck if given object is a function expression.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.is_ifelse-Tuple{Any}","page":"Analysis","title":"Expronicon.is_ifelse","text":"is_ifelse(ex)\n\nCheck if ex is an if ... elseif ... else ... end expression.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.is_kw_function-Tuple{Any}","page":"Analysis","title":"Expronicon.is_kw_function","text":"is_kw_function(def)\n\nCheck if a given function definition supports keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.is_literal-Tuple{Any}","page":"Analysis","title":"Expronicon.is_literal","text":"is_literal(x)\n\nCheck if x is a literal value.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.is_struct-Tuple{Any}","page":"Analysis","title":"Expronicon.is_struct","text":"is_struct(ex)\n\nCheck if ex is a struct expression.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.is_struct_not_kw_struct-Tuple{Any}","page":"Analysis","title":"Expronicon.is_struct_not_kw_struct","text":"is_struct_not_kw_struct(ex)\n\nCheck if ex is a struct expression excluding keyword struct syntax.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.split_doc-Tuple{Expr}","page":"Analysis","title":"Expronicon.split_doc","text":"split_doc(ex::Expr) -> line, doc, expr\n\nSplit doc string from given expression.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.split_function-Tuple{Expr}","page":"Analysis","title":"Expronicon.split_function","text":"split_function(ex::Expr) -> head, call, body\n\nSplit function head declaration with function body.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.split_function_head-Tuple{Expr}","page":"Analysis","title":"Expronicon.split_function_head","text":"split_function_head(ex::Expr) -> name, args, kw, whereparams\n\nSplit function head to name, arguments, keyword arguments and where parameters.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.split_struct-Tuple{Expr}","page":"Analysis","title":"Expronicon.split_struct","text":"split_struct(ex::Expr) -> ismutable, name, typevars, supertype, body\n\nSplit struct definition head and body.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.split_struct_name-Tuple{Any}","page":"Analysis","title":"Expronicon.split_struct_name","text":"split_struct_name(ex::Expr) -> name, typevars, supertype\n\nSplit the name, type parameters and supertype definition from struct declaration head.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.support_default-Tuple{Any}","page":"Analysis","title":"Expronicon.support_default","text":"support_default(f)\n\nCheck if field type f supports default value.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#Expronicon.@expr-Tuple{Any, Any}","page":"Analysis","title":"Expronicon.@expr","text":"@expr <type> <expression>\n\nReturn the expression in given type.\n\nExample\n\njulia> ex = @expr JLKwStruct struct Foo{N, T}\n           x::T = 1\n       end\n#= kw =# struct Foo{N, T}\n    #= /home/roger/code/julia/Expronicon/test/analysis.jl:5 =#\n    x::T = 1\nend\n\n\n\n\n\n","category":"macro"},{"location":"analysis/#Expronicon.@expr-Tuple{Any}","page":"Analysis","title":"Expronicon.@expr","text":"@expr <expression>\n\nReturn the original expression object.\n\nExample\n\njulia> ex = @expr x + 1\n:(x + 1)\n\n\n\n\n\n","category":"macro"},{"location":"analysis/#Expronicon.@test_expr-Tuple{Any, Any}","page":"Analysis","title":"Expronicon.@test_expr","text":"@test_expr <type> <ex>\n\nTest if the syntax type generates the same expression ex. Returns the corresponding syntax type instance. Requires using Test before using this macro.\n\nExample\n\ndef = @test_expr JLFunction function (x, y)\n    return 2\nend\n@test is_kw_fn(def) == false\n\n\n\n\n\n","category":"macro"},{"location":"analysis/#Expronicon.@test_expr-Tuple{Expr}","page":"Analysis","title":"Expronicon.@test_expr","text":"@test_expr <expr> == <expr>\n\nTest if two expression is equivalent semantically, this uses compare_expr to decide if they are equivalent, ignores things such as LineNumberNode generated Symbol in Expr(:curly, ...) or Expr(:where, ...).\n\n\n\n\n\n","category":"macro"},{"location":"codegen/#CodeGen","page":"CodeGen","title":"CodeGen","text":"","category":"section"},{"location":"codegen/","page":"CodeGen","title":"CodeGen","text":"Code generators, functions that generates Julia Expr from given arguments, Expronicon types. ","category":"page"},{"location":"codegen/","page":"CodeGen","title":"CodeGen","text":"Modules = [Expronicon]\nPages = [\"codegen.jl\"]","category":"page"},{"location":"codegen/#Expronicon.codegen_ast-Tuple{Any}","page":"CodeGen","title":"Expronicon.codegen_ast","text":"codegen_ast(def)\n\nGenerate Julia AST object Expr from a given syntax type.\n\nExample\n\nOne can generate the Julia AST object from a JLKwStruct syntax type.\n\njulia> def = @expr JLKwStruct struct Foo{N, T}\n                  x::T = 1\n              end\n#= kw =# struct Foo{N, T}\n    #= REPL[19]:2 =#\n    x::T = 1\nend\n\njulia> codegen_ast(def)|>rm_lineinfo\nquote\n    struct Foo{N, T}\n        x::T\n    end\n    begin\n        function Foo{N, T}(; x = 1) where {N, T}\n            Foo{N, T}(x)\n        end\n        function Foo{N}(; x::T = 1) where {N, T}\n            Foo{N, T}(x)\n        end\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Expronicon.codegen_ast_fields-Tuple{Any}","page":"CodeGen","title":"Expronicon.codegen_ast_fields","text":"codegen_ast_fields(fields; just_name::Bool=true)\n\nGenerate a list of Julia AST object for each field, only generate a list of field names by default, option just_name can be turned off to call codegen_ast on each field object.\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Expronicon.codegen_ast_kwfn","page":"CodeGen","title":"Expronicon.codegen_ast_kwfn","text":"codegen_ast_kwfn(def[, name = nothing])\n\nGenerate the keyword function from a Julia struct definition.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, T}\n                  x::T = 1\n              end\n#= kw =# struct Foo{N, T}\n    #= REPL[19]:2 =#\n    x::T = 1\nend\n\njulia> codegen_ast_kwfn(def)|>prettify\nquote\n    function Foo{N, T}(; x = 1) where {N, T}\n        Foo{N, T}(x)\n    end\n    function Foo{N}(; x::T = 1) where {N, T}\n        Foo{N, T}(x)\n    end\nend\n\njulia> def = @expr JLKwStruct struct Foo\n                  x::Int = 1\n              end\n#= kw =# struct Foo\n    #= REPL[23]:2 =#\n    x::Int = 1\nend\n\njulia> codegen_ast_kwfn(def)|>prettify\nquote\n    function Foo(; x = 1)\n        Foo(x)\n    end\n    nothing\nend\n\n\n\n\n\n","category":"function"},{"location":"codegen/#Expronicon.codegen_ast_kwfn_infer","page":"CodeGen","title":"Expronicon.codegen_ast_kwfn_infer","text":"codegen_ast_kwfn_infer(def, name = nothing)\n\nGenerate the keyword function that infers the type.\n\n\n\n\n\n","category":"function"},{"location":"codegen/#Expronicon.codegen_ast_kwfn_plain","page":"CodeGen","title":"Expronicon.codegen_ast_kwfn_plain","text":"codegen_ast_kwfn_plain(def[, name = nothing])\n\nGenerate the plain keyword function that does not infer type variables. So that one can use the type conversions defined by constructors.\n\n\n\n\n\n","category":"function"},{"location":"codegen/#Expronicon.codegen_ast_struct-Tuple{Any}","page":"CodeGen","title":"Expronicon.codegen_ast_struct","text":"codegen_ast_struct(def)\n\nGenerate pure Julia struct Expr from struct definition. This is equivalent to codegen_ast for JLStruct. See also codegen_ast.\n\nExample\n\njulia> def = JLKwStruct(:(struct Foo\n           x::Int=1\n           \n           Foo(x::Int) = new(x)\n       end))\nstruct Foo\n    x::Int = 1\nend\n\njulia> codegen_ast_struct(def)\n:(struct Foo\n      #= REPL[21]:2 =#\n      x::Int\n      Foo(x::Int) = begin\n              #= REPL[21]:4 =#\n              new(x)\n          end\n  end)\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Expronicon.codegen_ast_struct_body-Tuple{Any}","page":"CodeGen","title":"Expronicon.codegen_ast_struct_body","text":"codegen_ast_struct_body(def)\n\nGenerate the struct body.\n\nExample\n\njulia> def = JLStruct(:(struct Foo\n           x::Int\n           \n           Foo(x::Int) = new(x)\n       end))\nstruct Foo\n    x::Int\nend\n\njulia> codegen_ast_struct_body(def)\nquote\n    #= REPL[15]:2 =#\n    x::Int\n    Foo(x::Int) = begin\n            #= REPL[15]:4 =#\n            new(x)\n        end\nend\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Expronicon.codegen_ast_struct_head-Tuple{Any}","page":"CodeGen","title":"Expronicon.codegen_ast_struct_head","text":"codegen_ast_struct_head(def)\n\nGenerate the struct head.\n\nExample\n\njulia> using Expronicon\n\njulia> def = JLStruct(:(struct Foo{T} end))\nstruct Foo{T}\nend\n\njulia> codegen_ast_struct_head(def)\n:(Foo{T})\n\njulia> def = JLStruct(:(struct Foo{T} <: AbstractArray end))\nstruct Foo{T} <: AbstractArray\nend\n\njulia> codegen_ast_struct_head(def)\n:(Foo{T} <: AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Expronicon.codegen_match","page":"CodeGen","title":"Expronicon.codegen_match","text":"codegen_match(f, x[, line::LineNumberNode=LineNumberNode(0), mod::Module=Main])\n\nGenerate a zero dependency match expression using MLStyle code generator, the syntax is identical to MLStyle.\n\nExample\n\ncodegen_match(:x) do\n    quote\n        1 => true\n        2 => false\n        _ => nothing\n    end\nend\n\nThis code generates the following corresponding MLStyle expression\n\n@match x begin\n    1 => true\n    2 => false\n    _ => nothing\nend\n\n\n\n\n\n","category":"function"},{"location":"codegen/#Expronicon.struct_name_plain-Tuple{Any}","page":"CodeGen","title":"Expronicon.struct_name_plain","text":"struct_name_plain(def)\n\nPlain constructor name. See also struct_name_without_inferable.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, Inferable}\n    x::Inferable = 1\nend\n\njulia> struct_name_plain(def)\n:(Foo{N, Inferable})\n\n\n\n\n\n","category":"method"},{"location":"codegen/#Expronicon.struct_name_without_inferable-Tuple{Any}","page":"CodeGen","title":"Expronicon.struct_name_without_inferable","text":"struct_name_without_inferable(def; leading_inferable::Bool=true)\n\nConstructor name that assume some of the type variables is inferred. See also struct_name_plain. The kwarg leading_inferable can be used to configure whether to preserve the leading inferable type variables, the default is true to be consistent with the default julia constructors.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, Inferable}\n    x::Inferable = 1\nend\n\njulia> struct_name_without_inferable(def)\n:(Foo{N})\n\njulia> def = @expr JLKwStruct struct Foo{Inferable, NotInferable}\n    x::Inferable\nend\n\njulia> struct_name_without_inferable(def; leading_inferable=true)\n:(Foo{Inferable, NotInferable})\n\njulia> struct_name_without_inferable(def; leading_inferable=false)\n:(Foo{NotInferable})\n\n\n\n\n\n","category":"method"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using ANSIColoredPrinters\nfunction show_ascii(x)\n    buf = IOBuffer()\n    print(buf, x)\n    HTMLPrinter(buf, root_class=\"terminal-output\")\nend","category":"page"},{"location":"#Expronicon","page":"Quick Start","title":"Expronicon","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Downstream)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Collective tools for metaprogramming on Julia Expr, the meta programming standard library for MLStyle.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Meta programming in general can be decomposed into three steps:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"analyse the given expression\ntransform the given expression to:\nanother target expression\na convenient intermediate representation (IR) that is easy to further manipulate/analyse\ngenerate the target code, the target code can be:\nmost commonly the Julia Expr\nanother language's abstract/concrete syntax tree\na lower-level IR","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"The package Expronicon is thus written to assist you writing meta programs in the above manner.","category":"page"},{"location":"#Builtin-Syntax-Types","page":"Quick Start","title":"Builtin Syntax Types","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"One of the most important tool in Expronicon is the syntax types, these are types describing a specific Julia syntax, e.g JLFunction describes Julia's function definition syntax. The syntax type uses a canonical data structure to represent various syntax that has the same semantic, which is convenient when one wants to manipulate, generate such objects.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"They will allow you to:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"easily analysis a given Julia Expr by converting it to the syntax type\neasily manipulate a given Julia Expr with data structure designed for easier manipulation\neasily generate a Julia Expr using codegen_ast.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Let's take JLFunction as our example again, in Julia, function can be declared in many different ways:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can define a function using the short form","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"f(x) = x","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"or you can declare the same function using the function keyword","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"function f(x)\n    return x\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"If we look at their expression object, we will find they actually have quite different expression structure:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using Expronicon # hide\nex1 = @expr f(x) = x","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex2 = @expr function f(x)\n    return x\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"here we use a convenient tool to obtain the Julia expression object provided by Expronicon, the @expr macro.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Now if we convert them to the JLFunction type","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl1 = JLFunction(ex1)\nshow_ascii(jl1)# hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl2 = JLFunction(ex2)\nshow_ascii(jl2)# hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can see they have the same structure under the representation of JLFunction.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"dump(jl1)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"dump(jl2)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can easily access to some important information of this function by accessing the fields","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl1.name\njl1.args\njl1.body","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"This is the same for other syntax types, e.g we can get the corresponding syntax type instance of a struct definition","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def = @expr JLStruct struct Foo{T} <: AbstractType\n    x::Int\n    y::T\nend\nshow_ascii(def) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we again use @expr for convenience, however you can also just convert the expression to JLStruct manually","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex = quote\n    struct Foo{T} <: AbstractType\n        x::Int\n        y::T\n    end\nend\ndef = JLStruct(ex.args[2])\nshow_ascii(def) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"once you have the corresponding JLStruct object, you can access many useful information directly","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def.name\ndef.typevars\ndef.supertype\ntypeof(def.fields[1])\ndef.fields[1].name\ndef.fields[1].type","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Some syntax types are defined for easy manipulation such as JLIfElse, Julia's representation of if ... elseif ... else ... end statement is a recursive tree in Expr, which sometimes is not very convenient to manipulate or analysis, for example, it is not easy to access all the conditions in a long ifelse statement","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex = @expr if x > 100\n    x + 1\nelseif x > 90\n    x + 2\nelseif x > 80\n    x + 3\nelse\n    error(\"some error msg\")\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can find each condition","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex.args[1]\nex.args[3].args[1]\nex.args[3].args[3].args[1]\nex.args[3].args[3].args[3]","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"imagine how would you construct such expression from scratch, or how would you access all the conditions. Thus JLIfElse allows you to access/manipulate ifelse statements directly as a dict-like object","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl = JLIfElse(ex);\njl.map\njl.otherwise","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"you can access to each condition and its action using the condition as your key","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl.map[:(x > 100)]","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"similarly, we can easily construct a JLIfElse","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl = JLIfElse()\njl.map[:(x > 100)] = :(x + 1)\njl.map[:(x > 80)] = :(x + 2)\njl.otherwise = :(error(\"some error msg\"))\njl\nshow_ascii(jl) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"now let's generate back to Expr so that we can give Julia back some executable expression","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"codegen_ast(jl)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can find available syntax types in Syntax Types","category":"page"},{"location":"#Pattern-Matching","page":"Quick Start","title":"Pattern Matching","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Since Expronicon serves as the meta programming stdlib for MLStyle, you can also use the syntax types along with MLStyle, e.g","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using MLStyle\nusing Expronicon\n\nf = @Î» begin\n   JLFunction(;name=:foo, args) => (args, )\n   JLFunction(;name=:boo, args) => (args, )\n   _ => nothing\nend\n\nex_foo = @expr function foo(x::Int, y::T) where {T <: Real}\n    x + y\nend\n\nex_boo = @expr function foo(x::Int)\n    x\nend\nnothing # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"then we can check if our match function gives the right result","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"f(ex_foo)\nf(ex_boo)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can use any syntax types builtin as your expression template to match using MLStyle. If you define your own syntax type, you can also support pattern matching via @syntax_pattern.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"@syntax_pattern","category":"page"},{"location":"#Expronicon.@syntax_pattern","page":"Quick Start","title":"Expronicon.@syntax_pattern","text":"@syntax_pattern <syntax type> <syntax checker>\n\nExample\n\nstruct MyFunction\n    ex :: Expr\n    test_field :: Any\nend\n\nis_xxx(ex::Expr) = Meta.isexpr(ex, :function)\nis_xxx(_) = false\n\njulia> MyFunction(ex::Expr) = MyFunction(ex, :aaa)\njulia> @syntax_pattern(MyFunction, is_xxx)\n\njulia> @match :(function f() end) begin\n        MyFunction(;test_field) => test_field\n    end\n:aaa\n\n\n\n\n\n","category":"macro"},{"location":"#Analysis-Functions","page":"Quick Start","title":"Analysis Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Expronicon provides a lot common analysis functions, you can find the list of them in Analysis. you can use them to check if the expression satisfy certain property, e.g you can check if a given object is a struct definition via is_struct, or check if a given function definition supports keyword arguments via is_kw_function.","category":"page"},{"location":"#Transform-Functions","page":"Quick Start","title":"Transform Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can find the list of them in Transform.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Transform functions usually takes an expression and returns an expression e.g sometimes you only want the name symbol of your function arguments","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def = @expr JLFunction function foo(x::Int, y::Real=2)\nend\nnothing # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def.args\nname_only.(def.args)","category":"page"},{"location":"#Code-Generation-Functions","page":"Quick Start","title":"Code Generation Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"The code generation functions help you generate other target expressions, e.g codegen_ast generates the Julia AST object Expr. All the syntax type can use codegen_ast to generate the corresponding Expr, there are also some other functions start with name codegen in CodeGen you may find useful.","category":"page"},{"location":"#Pretty-Printing","page":"Quick Start","title":"Pretty Printing","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Sometimes, when you define your own intermediate representation, you may want to pretty print your expression with colors and indents. Expronicon also provide some tools for this in Printings.","category":"page"},{"location":"printings/#Printings","page":"Printings","title":"Printings","text":"","category":"section"},{"location":"printings/","page":"Printings","title":"Printings","text":"Pretty printing functions.","category":"page"},{"location":"printings/","page":"Printings","title":"Printings","text":"Modules = [Expronicon]\nPages = [\"printing.jl\"]","category":"page"},{"location":"printings/#Expronicon.print_ast-Tuple{IO, Vararg{Any, N} where N}","page":"Printings","title":"Expronicon.print_ast","text":"print_ast(io::IO, xs...)\n\nPrint Julia AST. This is a custom implementation of Base.show(io, ::Expr).\n\n\n\n\n\n","category":"method"},{"location":"printings/#Expronicon.print_collection-Tuple{Any, Any}","page":"Printings","title":"Expronicon.print_collection","text":"print_collection(io, xs; delim=\",\")\n\nPrint a collection xs with deliminator delim, default is \",\".\n\n\n\n\n\n","category":"method"},{"location":"printings/#Expronicon.with_begin_end-Tuple{Any, IO}","page":"Printings","title":"Expronicon.with_begin_end","text":"with_begin_end(f, io::IO)\n\nPrint with begin ... end. See also with_marks, with_parathesis, with_curly, with_brackets.\n\n\n\n\n\n","category":"method"},{"location":"printings/#Expronicon.with_brackets-Tuple{Any, IO}","page":"Printings","title":"Expronicon.with_brackets","text":"with_brackets(f, io::IO)\n\nPrint with brackets. See also with_marks, with_parathesis, with_curly, with_begin_end.\n\n\n\n\n\n","category":"method"},{"location":"printings/#Expronicon.with_curly-Tuple{Any, IO}","page":"Printings","title":"Expronicon.with_curly","text":"with_curly(f, io::IO)\n\nPrint with curly parathesis. See also with_marks, with_parathesis, with_brackets, with_begin_end.\n\n\n\n\n\n","category":"method"},{"location":"printings/#Expronicon.with_double_quotes-Tuple{Any, IO}","page":"Printings","title":"Expronicon.with_double_quotes","text":"with_double_quotes(f, io::IO)\n\nPrint with double quotes.\n\n\n\n\n\n","category":"method"},{"location":"printings/#Expronicon.with_marks-Tuple{Any, IO, Any, Any}","page":"Printings","title":"Expronicon.with_marks","text":"with_marks(f, io, lhs, rhs)\n\nPrint using f with marks specified on LHS and RHS by lhs and rhs. See also with_parathesis, with_curly, with_brackets, with_begin_end.\n\n\n\n\n\n","category":"method"},{"location":"printings/#Expronicon.with_parathesis-Tuple{Any, IO}","page":"Printings","title":"Expronicon.with_parathesis","text":"with_parathesis(f, io::IO)\n\nPrint with parathesis. See also with_marks, with_curly, with_brackets, with_begin_end.\n\nExample\n\njulia> with_parathesis(stdout) do\n        print(1, \", \", 2)\n    end\n(1, 2)\n\n\n\n\n\n","category":"method"},{"location":"printings/#Expronicon.with_triple_quotes-Tuple{Any, IO}","page":"Printings","title":"Expronicon.with_triple_quotes","text":"with_triple_quotes(f, io::IO)\n\nPrint with triple quotes.\n\n\n\n\n\n","category":"method"},{"location":"printings/","page":"Printings","title":"Printings","text":"Expronicon.Color","category":"page"},{"location":"printings/#Expronicon.Color","page":"Printings","title":"Expronicon.Color","text":"julia Expr printing color schema\n\n\n\n\n\n","category":"module"}]
}
