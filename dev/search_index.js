var documenterSearchIndex = {"docs":
[{"location":"case/#Use-Cases","page":"Case Study","title":"Use Cases","text":"","category":"section"},{"location":"case/#Packages-Using-Expronicon","page":"Case Study","title":"Packages Using Expronicon","text":"","category":"section"},{"location":"case/","page":"Case Study","title":"Case Study","text":"Configurations: Configurations & Options made easy.","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Syntax-Types","page":"API Reference","title":"Syntax Types","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Convenient types for storing analysis results of a given Julia Expr, or for creating certain Julia objects easily. These types define some common syntax one would manipulate in Julia meta programming.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"JLFunction\nJLStruct\nJLKwStruct\nJLIfElse\nJLMatch\nJLFor\nJLField\nJLKwField\nNoDefault\nno_default\nJLExpr","category":"page"},{"location":"reference/#Expronicon.JLFunction","page":"API Reference","title":"Expronicon.JLFunction","text":"JLFunction <: JLExpr\n\nType describes a Julia function declaration expression.\n\nExample\n\nConstruct a function expression\n\njulia> JLFunction(;name=:foo, args=[:(x::T)], body= quote 1+1 end, head=:function, whereparams=[:T])\nfunction foo(x::T) where {T}\n    #= REPL[25]:1 =#    \n    1 + 1    \nend\n\nDecompose a function expression\n\njulia> ex = :(function foo(x::T) where {T}\n           #= REPL[25]:1 =#    \n           1 + 1    \n       end)\n:(function foo(x::T) where T\n      #= REPL[26]:1 =#\n      #= REPL[26]:3 =#\n      1 + 1\n  end)\n\njulia> jl = JLFunction(ex)\nfunction foo(x::T) where {T}\n    #= REPL[26]:1 =#    \n    #= REPL[26]:3 =#    \n    1 + 1    \nend\n\nGenerate Expr from JLFunction\n\njulia> codegen_ast(jl)\n:(function foo(x::T) where T\n      #= REPL[26]:1 =#\n      #= REPL[26]:3 =#\n      1 + 1\n  end)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLStruct","page":"API Reference","title":"Expronicon.JLStruct","text":"JLStruct <: JLExpr\n\nType describes a Julia struct.\n\nExample\n\nConstruct a Julia struct.\n\njulia> JLStruct(;name=:Foo, typevars=[:T], fields=[JLField(;name=:x, type=Int)])\nstruct Foo{T}\n    x::Int64\nend\n\nDecompose a Julia struct expression\n\njulia> ex = :(struct Foo{T}\n           x::Int64\n       end)\n:(struct Foo{T}\n      #= REPL[31]:2 =#\n      x::Int64\n  end)\n\njulia> jl = JLStruct(ex)\nstruct Foo{T}\n    #= REPL[31]:2 =#\n    x::Int64\nend\n\nGenerate a Julia struct expression\n\njulia> codegen_ast(jl)\n:(struct Foo{T}\n      #= REPL[31]:2 =#\n      x::Int64\n  end)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLKwStruct","page":"API Reference","title":"Expronicon.JLKwStruct","text":"JLKwStruct <: JLExpr\n\nType describes a Julia struct that allows keyword definition of defaults.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLIfElse","page":"API Reference","title":"Expronicon.JLIfElse","text":"JLIfElse <: JLExpr\n\nJLIfElse describes a Julia if ... elseif ... else ... end expression. It allows one to easily construct such expression by inserting condition and code block via a map.\n\nExample\n\nConstruct JLIfElse object\n\nOne can construct an ifelse as following\n\njulia> jl = JLIfElse()\nnothing\n\njulia> jl[:(foo(x))] = :(x = 1 + 1)\n:(x = 1 + 1)\n\njulia> jl[:(goo(x))] = :(y = 1 + 2)\n:(y = 1 + 2)\n\njulia> jl.otherwise = :(error(\"abc\"))\n:(error(\"abc\"))\n\njulia> jl\nif foo(x)\n    x = 1 + 1\nelseif goo(x)\n    y = 1 + 2\nelse\n    error(\"abc\")\nend\n\nGenerate the Julia Expr object\n\nto generate the corresponding Expr object, one can call codegen_ast.\n\njulia> codegen_ast(jl)\n:(if foo(x)\n      x = 1 + 1\n  elseif goo(x)\n      y = 1 + 2\n  else\n      error(\"abc\")\n  end)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLMatch","page":"API Reference","title":"Expronicon.JLMatch","text":"JLMatch <: JLExpr\n\nJLMatch describes a Julia pattern match expression defined by MLStyle. It allows one to construct such expression by simply assign each code block to the corresponding pattern expression.\n\nExample\n\nOne can construct a MLStyle pattern matching expression easily by assigning the corresponding pattern and its result to the map field.\n\njulia> jl = JLMatch(:x)\n#= line 0 =#\nnothing\n\njulia> jl = JLMatch(:x)\n#= line 0 =#\nnothing\n\njulia> jl.map[1] = true\ntrue\n\njulia> jl.map[2] = :(sin(x))\n:(sin(x))\n\njulia> jl\n#= line 0 =#\n@match x begin\n    1 => true\n    2 => sin(x)\n    _ =>     nothing\nend\n\nto generate the corresponding Julia Expr object, one can call codegen_ast.\n\njulia> codegen_ast(jl)\n:(let\n      true\n      var\"##return#263\" = nothing\n      var\"##265\" = x\n      if var\"##265\" isa Int64\n          #= line 0 =#\n          if var\"##265\" === 1\n              var\"##return#263\" = let\n                      true\n                  end\n              #= unused:1 =# @goto var\"####final#264#266\"\n          end\n          #= line 0 =#\n          if var\"##265\" === 2\n              var\"##return#263\" = let\n                      sin(x)\n                  end\n              #= unused:1 =# @goto var\"####final#264#266\"\n          end\n      end\n      #= line 0 =#\n      begin\n          var\"##return#263\" = let\n                  nothing\n              end\n          #= unused:1 =# @goto var\"####final#264#266\"\n      end\n      (error)(\"matching non-exhaustive, at #= line 0 =#\")\n      #= unused:1 =# @label var\"####final#264#266\"\n      var\"##return#263\"\n  end)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLFor","page":"API Reference","title":"Expronicon.JLFor","text":"JLFor <: JLExpr\n\nSyntax type for Julia for loop.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLField","page":"API Reference","title":"Expronicon.JLField","text":"JLField <: JLExpr\n\nType describes a Julia field in a Julia struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLKwField","page":"API Reference","title":"Expronicon.JLKwField","text":"JLKwField <: JLExpr\n\nType describes a Julia field that can have a default value in a Julia struct.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.NoDefault","page":"API Reference","title":"Expronicon.NoDefault","text":"NoDefault\n\nType describes a field should have no default value.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.no_default","page":"API Reference","title":"Expronicon.no_default","text":"const no_default = NoDefault()\n\nConstant instance for NoDefault that describes a field should have no default value.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Expronicon.JLExpr","page":"API Reference","title":"Expronicon.JLExpr","text":"abstract type JLExpr end\n\nAbstract type for Julia syntax type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Analysis","page":"API Reference","title":"Analysis","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Functions for analysing a given Julia Expr, e.g splitting Julia function/struct definitions etc.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon]\nPages = [\"analysis.jl\"]","category":"page"},{"location":"reference/#Expronicon.JLFor-Tuple{Expr}","page":"API Reference","title":"Expronicon.JLFor","text":"JLFor(ex::Expr)\n\nCreate a JLFor from given Julia for loop expression.\n\nExample\n\njulia> ex = @expr for i in 1:10, j in 1:j\n           M[i, j] += 1\n       end\n:(for i = 1:10, j = 1:j\n      #= REPL[3]:2 =#\n      M[i, j] += 1\n  end)\n\njulia> jl = JLFor(ex)\nfor i in 1 : 10,\n    j in 1 : j\n    #= loop body =#\n    begin\n        #= REPL[3]:2 =#        \n        M[i, j] += 1        \n    end\nend\n\njulia> jl.vars\n2-element Vector{Any}:\n :i\n :j\n\njulia> jl.iterators\n2-element Vector{Any}:\n :(1:10)\n :(1:j)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.JLFunction-Tuple{Expr}","page":"API Reference","title":"Expronicon.JLFunction","text":"JLFunction(ex::Expr)\n\nCreate a JLFunction object from a Julia function Expr.\n\nExample\n\njulia> JLFunction(:(f(x) = 2))\nf(x) = begin\n    #= REPL[37]:1 =#    \n    2    \nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.JLIfElse-Tuple{Expr}","page":"API Reference","title":"Expronicon.JLIfElse","text":"JLIfElse(ex::Expr)\n\nCreate a JLIfElse from given Julia ifelse Expr.\n\nExample\n\njulia> ex = :(if foo(x)\n             x = 1 + 1\n         elseif goo(x)\n             y = 1 + 2\n         else\n             error(\"abc\")\n         end)\n:(if foo(x)\n      #= REPL[41]:2 =#\n      x = 1 + 1\n  elseif #= REPL[41]:3 =# goo(x)\n      #= REPL[41]:4 =#\n      y = 1 + 2\n  else\n      #= REPL[41]:6 =#\n      error(\"abc\")\n  end)\n\njulia> JLIfElse(ex)\nif foo(x)\n    begin\n        #= REPL[41]:2 =#        \n        x = 1 + 1        \n    end\nelseif begin\n    #= REPL[41]:3 =#    \n    goo(x)    \nend\n    begin\n        #= REPL[41]:4 =#        \n        y = 1 + 2        \n    end\nelse\n    begin\n        #= REPL[41]:6 =#        \n        error(\"abc\")        \n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.JLKwStruct-2","page":"API Reference","title":"Expronicon.JLKwStruct","text":"JLKwStruct(ex::Expr, typealias=nothing)\n\nCreate a JLKwStruct from given Julia struct Expr, with an option to attach an alias to this type name.\n\nExample\n\njulia> JLKwStruct(:(struct Foo\n           x::Int = 1\n       end))\n#= kw =# struct Foo\n    #= REPL[39]:2 =#\n    x::Int = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLStruct-Tuple{Expr}","page":"API Reference","title":"Expronicon.JLStruct","text":"JLStruct(ex::Expr)\n\nCreate a JLStruct object from a Julia struct Expr.\n\nExample\n\njulia> JLStruct(:(struct Foo\n           x::Int\n       end))\nstruct Foo\n    #= REPL[38]:2 =#\n    x::Int\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.compare_expr-Tuple{Any, Any}","page":"API Reference","title":"Expronicon.compare_expr","text":"compare_expr(lhs, rhs)\n\nCompare two expression of type Expr or Symbol semantically, which:\n\nignore the detail value LineNumberNode in comparision\nignore the detailed name of typevars in Expr(:curly, ...) or Expr(:where, ...)\n\nThis gives a way to compare two Julia expression semantically which means although some details of the expression is different but they should produce the same lowered code.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.compare_vars-Tuple{Any, Any}","page":"API Reference","title":"Expronicon.compare_vars","text":"compare_vars(lhs, rhs)\n\nCompare two expression by assuming all Symbols are variables, thus their value doesn't matter, only where they are matters under this assumption. See also compare_expr.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.has_kwfn_constructor","page":"API Reference","title":"Expronicon.has_kwfn_constructor","text":"has_kwfn_constructor(def[, name = struct_name_plain(def)])\n\nCheck if the struct definition contains keyword function constructor of name. The constructor name to check by default is the plain constructor which does not infer any type variables and requires user to input all type variables. See also struct_name_plain.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expronicon.has_plain_constructor","page":"API Reference","title":"Expronicon.has_plain_constructor","text":"has_plain_constructor(def, name = struct_name_plain(def))\n\nCheck if the struct definition contains the plain constructor of name. By default the name is the inferable name struct_name_plain.\n\nExample\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::Int\n    y::N\n\n    Foo{T, N}(x, y) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # true\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo(x, y) = new{typeof(x), typeof(y)}(x, y)\nend\n\nhas_plain_constructor(def) # false\n\nthe arguments must have no type annotations.\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo{T, N}(x::T, y::N) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # false\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expronicon.is_field-Tuple{Any}","page":"API Reference","title":"Expronicon.is_field","text":"is_field(ex)\n\nCheck if ex is a valid field expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.is_field_default-Tuple{Any}","page":"API Reference","title":"Expronicon.is_field_default","text":"is_field_default(ex)\n\nCheck if ex is a <field expr> = <default expr> expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.is_for-Tuple{Any}","page":"API Reference","title":"Expronicon.is_for","text":"is_for(ex)\n\nCheck if ex is a for loop expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.is_function-Tuple{Any}","page":"API Reference","title":"Expronicon.is_function","text":"is_function(def)\n\nCheck if given object is a function expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.is_ifelse-Tuple{Any}","page":"API Reference","title":"Expronicon.is_ifelse","text":"is_ifelse(ex)\n\nCheck if ex is an if ... elseif ... else ... end expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.is_kw_function-Tuple{Any}","page":"API Reference","title":"Expronicon.is_kw_function","text":"is_kw_function(def)\n\nCheck if a given function definition supports keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.is_literal-Tuple{Any}","page":"API Reference","title":"Expronicon.is_literal","text":"is_literal(x)\n\nCheck if x is a literal value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.is_struct-Tuple{Any}","page":"API Reference","title":"Expronicon.is_struct","text":"is_struct(ex)\n\nCheck if ex is a struct expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.is_struct_not_kw_struct-Tuple{Any}","page":"API Reference","title":"Expronicon.is_struct_not_kw_struct","text":"is_struct_not_kw_struct(ex)\n\nCheck if ex is a struct expression excluding keyword struct syntax.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.split_doc-Tuple{Expr}","page":"API Reference","title":"Expronicon.split_doc","text":"split_doc(ex::Expr) -> line, doc, expr\n\nSplit doc string from given expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.split_function-Tuple{Expr}","page":"API Reference","title":"Expronicon.split_function","text":"split_function(ex::Expr) -> head, call, body\n\nSplit function head declaration with function body.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.split_function_head-Tuple{Expr}","page":"API Reference","title":"Expronicon.split_function_head","text":"split_function_head(ex::Expr) -> name, args, kw, whereparams, rettype\n\nSplit function head to name, arguments, keyword arguments and where parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.split_struct-Tuple{Expr}","page":"API Reference","title":"Expronicon.split_struct","text":"split_struct(ex::Expr) -> ismutable, name, typevars, supertype, body\n\nSplit struct definition head and body.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.split_struct_name-Tuple{Any}","page":"API Reference","title":"Expronicon.split_struct_name","text":"split_struct_name(ex::Expr) -> name, typevars, supertype\n\nSplit the name, type parameters and supertype definition from struct declaration head.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.support_default-Tuple{Any}","page":"API Reference","title":"Expronicon.support_default","text":"support_default(f)\n\nCheck if field type f supports default value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.@expr-Tuple{Any, Any}","page":"API Reference","title":"Expronicon.@expr","text":"@expr <type> <expression>\n\nReturn the expression in given type.\n\nExample\n\njulia> ex = @expr JLKwStruct struct Foo{N, T}\n           x::T = 1\n       end\n#= kw =# struct Foo{N, T}\n    #= /home/roger/code/julia/Expronicon/test/analysis.jl:5 =#\n    x::T = 1\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Expronicon.@expr-Tuple{Any}","page":"API Reference","title":"Expronicon.@expr","text":"@expr <expression>\n\nReturn the original expression object.\n\nExample\n\njulia> ex = @expr x + 1\n:(x + 1)\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Expronicon.@test_expr-Tuple{Any, Any}","page":"API Reference","title":"Expronicon.@test_expr","text":"@test_expr <type> <ex>\n\nTest if the syntax type generates the same expression ex. Returns the corresponding syntax type instance. Requires using Test before using this macro.\n\nExample\n\ndef = @test_expr JLFunction function (x, y)\n    return 2\nend\n@test is_kw_fn(def) == false\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Expronicon.@test_expr-Tuple{Expr}","page":"API Reference","title":"Expronicon.@test_expr","text":"@test_expr <expr> == <expr>\n\nTest if two expression is equivalent semantically, this uses compare_expr to decide if they are equivalent, ignores things such as LineNumberNode generated Symbol in Expr(:curly, ...) or Expr(:where, ...).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Transform","page":"API Reference","title":"Transform","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Some common transformations for Julia Expr, these functions takes an Expr and returns an Expr.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon]\nPages = [\"transform.jl\"]","category":"page"},{"location":"reference/#Expronicon.eval_interp-Tuple{Module, Any}","page":"API Reference","title":"Expronicon.eval_interp","text":"eval_interp(m::Module, ex)\n\nevaluate the interpolation operator in ex inside given module m.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.eval_literal-Tuple{Module, Any}","page":"API Reference","title":"Expronicon.eval_literal","text":"eval_literal(m::Module, ex)\n\nEvaluate the literal values and insert them back to the expression. The literal value can be checked via is_literal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.flatten_blocks-Tuple{Any}","page":"API Reference","title":"Expronicon.flatten_blocks","text":"flatten_blocks(ex)\n\nRemove hierachical expression blocks.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.name_only-Tuple{Any}","page":"API Reference","title":"Expronicon.name_only","text":"name_only(ex)\n\nRemove everything else leaving just names, currently supports function calls, type with type variables, subtype operator <: and type annotation ::.\n\nExample\n\njulia> using Expronicon\n\njulia> name_only(:(sin(2)))\n:sin\n\njulia> name_only(:(Foo{Int}))\n:Foo\n\njulia> name_only(:(Foo{Int} <: Real))\n:Foo\n\njulia> name_only(:(x::Int))\n:x\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.prettify-Tuple{Any}","page":"API Reference","title":"Expronicon.prettify","text":"prettify(ex)\n\nPrettify given expression, remove all LineNumberNode and extra code blocks.\n\ntips: Tips\nthe LineNumberNode inside macro calls won't be removed since the macrocall expression requires a LineNumberNode. See also issues/#9.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.rm_annotations-Tuple{Any}","page":"API Reference","title":"Expronicon.rm_annotations","text":"rm_annotations(x)\n\nRemove type annotation of given expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.rm_lineinfo-Tuple{Any}","page":"API Reference","title":"Expronicon.rm_lineinfo","text":"rm_lineinfo(ex)\n\nRemove LineNumberNode in a given expression.\n\ntips: Tips\nthe LineNumberNode inside macro calls won't be removed since the macrocall expression requires a LineNumberNode. See also issues/#9.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.rm_nothing-Tuple{Any}","page":"API Reference","title":"Expronicon.rm_nothing","text":"rm_nothing(ex)\n\nRemove the constant value nothing in given expression ex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.subtitute-Tuple{Expr, Pair}","page":"API Reference","title":"Expronicon.subtitute","text":"subtitute(ex::Expr, old=>new)\n\nSubtitute the old symbol old with new.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CodeGen","page":"API Reference","title":"CodeGen","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Code generators, functions that generates Julia Expr from given arguments, Expronicon types. ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon]\nPages = [\"codegen.jl\"]","category":"page"},{"location":"reference/#Expronicon.codegen_ast-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast","text":"codegen_ast(def)\n\nGenerate Julia AST object Expr from a given syntax type.\n\nExample\n\nOne can generate the Julia AST object from a JLKwStruct syntax type.\n\njulia> def = @expr JLKwStruct struct Foo{N, T}\n                  x::T = 1\n              end\n#= kw =# struct Foo{N, T}\n    #= REPL[19]:2 =#\n    x::T = 1\nend\n\njulia> codegen_ast(def)|>rm_lineinfo\nquote\n    struct Foo{N, T}\n        x::T\n    end\n    begin\n        function Foo{N, T}(; x = 1) where {N, T}\n            Foo{N, T}(x)\n        end\n        function Foo{N}(; x::T = 1) where {N, T}\n            Foo{N, T}(x)\n        end\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.codegen_ast_fields-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast_fields","text":"codegen_ast_fields(fields; just_name::Bool=true)\n\nGenerate a list of Julia AST object for each field, only generate a list of field names by default, option just_name can be turned off to call codegen_ast on each field object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.codegen_ast_kwfn","page":"API Reference","title":"Expronicon.codegen_ast_kwfn","text":"codegen_ast_kwfn(def[, name = nothing])\n\nGenerate the keyword function from a Julia struct definition.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, T}\n                  x::T = 1\n              end\n#= kw =# struct Foo{N, T}\n    #= REPL[19]:2 =#\n    x::T = 1\nend\n\njulia> codegen_ast_kwfn(def)|>prettify\nquote\n    function Foo{N, T}(; x = 1) where {N, T}\n        Foo{N, T}(x)\n    end\n    function Foo{N}(; x::T = 1) where {N, T}\n        Foo{N, T}(x)\n    end\nend\n\njulia> def = @expr JLKwStruct struct Foo\n                  x::Int = 1\n              end\n#= kw =# struct Foo\n    #= REPL[23]:2 =#\n    x::Int = 1\nend\n\njulia> codegen_ast_kwfn(def)|>prettify\nquote\n    function Foo(; x = 1)\n        Foo(x)\n    end\n    nothing\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expronicon.codegen_ast_kwfn_infer","page":"API Reference","title":"Expronicon.codegen_ast_kwfn_infer","text":"codegen_ast_kwfn_infer(def, name = nothing)\n\nGenerate the keyword function that infers the type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expronicon.codegen_ast_kwfn_plain","page":"API Reference","title":"Expronicon.codegen_ast_kwfn_plain","text":"codegen_ast_kwfn_plain(def[, name = nothing])\n\nGenerate the plain keyword function that does not infer type variables. So that one can use the type conversions defined by constructors.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expronicon.codegen_ast_struct-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast_struct","text":"codegen_ast_struct(def)\n\nGenerate pure Julia struct Expr from struct definition. This is equivalent to codegen_ast for JLStruct. See also codegen_ast.\n\nExample\n\njulia> def = JLKwStruct(:(struct Foo\n           x::Int=1\n           \n           Foo(x::Int) = new(x)\n       end))\nstruct Foo\n    x::Int = 1\nend\n\njulia> codegen_ast_struct(def)\n:(struct Foo\n      #= REPL[21]:2 =#\n      x::Int\n      Foo(x::Int) = begin\n              #= REPL[21]:4 =#\n              new(x)\n          end\n  end)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.codegen_ast_struct_body-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast_struct_body","text":"codegen_ast_struct_body(def)\n\nGenerate the struct body.\n\nExample\n\njulia> def = JLStruct(:(struct Foo\n           x::Int\n           \n           Foo(x::Int) = new(x)\n       end))\nstruct Foo\n    x::Int\nend\n\njulia> codegen_ast_struct_body(def)\nquote\n    #= REPL[15]:2 =#\n    x::Int\n    Foo(x::Int) = begin\n            #= REPL[15]:4 =#\n            new(x)\n        end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.codegen_ast_struct_head-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast_struct_head","text":"codegen_ast_struct_head(def)\n\nGenerate the struct head.\n\nExample\n\njulia> using Expronicon\n\njulia> def = JLStruct(:(struct Foo{T} end))\nstruct Foo{T}\nend\n\njulia> codegen_ast_struct_head(def)\n:(Foo{T})\n\njulia> def = JLStruct(:(struct Foo{T} <: AbstractArray end))\nstruct Foo{T} <: AbstractArray\nend\n\njulia> codegen_ast_struct_head(def)\n:(Foo{T} <: AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.struct_name_plain-Tuple{Any}","page":"API Reference","title":"Expronicon.struct_name_plain","text":"struct_name_plain(def)\n\nPlain constructor name. See also struct_name_without_inferable.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, Inferable}\n    x::Inferable = 1\nend\n\njulia> struct_name_plain(def)\n:(Foo{N, Inferable})\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.struct_name_without_inferable-Tuple{Any}","page":"API Reference","title":"Expronicon.struct_name_without_inferable","text":"struct_name_without_inferable(def; leading_inferable::Bool=true)\n\nConstructor name that assume some of the type variables is inferred. See also struct_name_plain. The kwarg leading_inferable can be used to configure whether to preserve the leading inferable type variables, the default is true to be consistent with the default julia constructors.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, Inferable}\n    x::Inferable = 1\nend\n\njulia> struct_name_without_inferable(def)\n:(Foo{N})\n\njulia> def = @expr JLKwStruct struct Foo{Inferable, NotInferable}\n    x::Inferable\nend\n\njulia> struct_name_without_inferable(def; leading_inferable=true)\n:(Foo{Inferable, NotInferable})\n\njulia> struct_name_without_inferable(def; leading_inferable=false)\n:(Foo{NotInferable})\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xcall-Tuple{Any, Vararg{Any, N} where N}","page":"API Reference","title":"Expronicon.xcall","text":"xcall(name, args...; kw...)\n\nCreate a function call to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xcall-Tuple{Module, Symbol, Vararg{Any, N} where N}","page":"API Reference","title":"Expronicon.xcall","text":"xcall(m::Module, name::Symbol, args...; kw...)\n\nCreate a function call to GlobalRef(m, name).\n\ntip: Tip\ndue to Revise/#616, to make your macro work with Revise, we use the dot expression Expr(:., <module>, QuoteNode(<name>)) instead of GlobalRef here.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xfirst-Tuple{Any}","page":"API Reference","title":"Expronicon.xfirst","text":"xfirst(collection)\n\nCreate a function call expression to Base.first.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xiterate-Tuple{Any, Any}","page":"API Reference","title":"Expronicon.xiterate","text":"xiterate(it, st)\n\nCreate a function call expression to Base.iterate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xiterate-Tuple{Any}","page":"API Reference","title":"Expronicon.xiterate","text":"xiterate(it)\n\nCreate a function call expression to Base.iterate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xlast-Tuple{Any}","page":"API Reference","title":"Expronicon.xlast","text":"xlast(collection)\n\nCreate a function call expression to Base.last.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xmap-Tuple{Any, Vararg{Any, N} where N}","page":"API Reference","title":"Expronicon.xmap","text":"xmap(f, xs...)\n\nCreate a function call expression to Base.map.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xmapreduce-Tuple{Any, Any, Vararg{Any, N} where N}","page":"API Reference","title":"Expronicon.xmapreduce","text":"xmapreduce(f, op, xs...)\n\nCreate a function call expression to Base.mapreduce.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xnamedtuple-Tuple{}","page":"API Reference","title":"Expronicon.xnamedtuple","text":"xnamedtuple(;kw...)\n\nCreate a NamedTuple expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xprint-Tuple","page":"API Reference","title":"Expronicon.xprint","text":"xprint(xs...)\n\nCreate a function call expression to Base.print.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xprintln-Tuple","page":"API Reference","title":"Expronicon.xprintln","text":"xprintln(xs...)\n\nCreate a function call expression to Base.println.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xpush-Tuple{Any, Vararg{Any, N} where N}","page":"API Reference","title":"Expronicon.xpush","text":"xpush(collection, items...)\n\nCreate a function call expression to Base.push!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xtuple-Tuple","page":"API Reference","title":"Expronicon.xtuple","text":"xtuple(xs...)\n\nCreate a Tuple expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Printings","page":"API Reference","title":"Printings","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Pretty printing functions.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon]\nPages = [\"printing.jl\"]","category":"page"},{"location":"reference/#Expronicon.print_expr-Tuple{Any}","page":"API Reference","title":"Expronicon.print_expr","text":"print_expr([io::IO], ex)\n\nPrint a given expression. ex can be a Expr or a syntax type JLExpr.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.sprint_expr-Tuple{Any}","page":"API Reference","title":"Expronicon.sprint_expr","text":"sprint_expr(ex; context=nothing)\n\nPrint given expression to String, see also print_expr.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using ANSIColoredPrinters\nfunction show_ascii(x)\n    buf = IOBuffer()\n    print(buf, x)\n    HTMLPrinter(buf, root_class=\"terminal-output\")\nend","category":"page"},{"location":"#Expronicon","page":"Quick Start","title":"Expronicon","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Downstream)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Collective tools for metaprogramming on Julia Expr, the meta programming standard library for MLStyle.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Meta programming in general can be decomposed into three steps:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"analyse the given expression\ntransform the given expression to:\nanother target expression\na convenient intermediate representation (IR) that is easy to further manipulate/analyse\ngenerate the target code, the target code can be:\nmost commonly the Julia Expr\nanother language's abstract/concrete syntax tree\na lower-level IR","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"The package Expronicon is thus written to assist you writing meta programs in the above manner.","category":"page"},{"location":"#Builtin-Syntax-Types","page":"Quick Start","title":"Builtin Syntax Types","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"One of the most important tool in Expronicon is the syntax types, these are types describing a specific Julia syntax, e.g JLFunction describes Julia's function definition syntax. The syntax type uses a canonical data structure to represent various syntax that has the same semantic, which is convenient when one wants to manipulate, generate such objects.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"They will allow you to:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"easily analysis a given Julia Expr by converting it to the syntax type\neasily manipulate a given Julia Expr with data structure designed for easier manipulation\neasily generate a Julia Expr using codegen_ast.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Let's take JLFunction as our example again, in Julia, function can be declared in many different ways:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can define a function using the short form","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"f(x) = x","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"or you can declare the same function using the function keyword","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"function f(x)\n    return x\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"If we look at their expression object, we will find they actually have quite different expression structure:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using Expronicon # hide\nex1 = @expr f(x) = x","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex2 = @expr function f(x)\n    return x\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"here we use a convenient tool to obtain the Julia expression object provided by Expronicon, the @expr macro.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Now if we convert them to the JLFunction type","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl1 = JLFunction(ex1)\nshow_ascii(jl1)# hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl2 = JLFunction(ex2)\nshow_ascii(jl2)# hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can see they have the same structure under the representation of JLFunction.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"dump(jl1)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"dump(jl2)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can easily access to some important information of this function by accessing the fields","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl1.name\njl1.args\njl1.body","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"This is the same for other syntax types, e.g we can get the corresponding syntax type instance of a struct definition","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def = @expr JLStruct struct Foo{T} <: AbstractType\n    x::Int\n    y::T\nend\nshow_ascii(def) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we again use @expr for convenience, however you can also just convert the expression to JLStruct manually","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex = quote\n    struct Foo{T} <: AbstractType\n        x::Int\n        y::T\n    end\nend\ndef = JLStruct(ex.args[2])\nshow_ascii(def) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"once you have the corresponding JLStruct object, you can access many useful information directly","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def.name\ndef.typevars\ndef.supertype\ntypeof(def.fields[1])\ndef.fields[1].name\ndef.fields[1].type","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Some syntax types are defined for easy manipulation such as JLIfElse, Julia's representation of if ... elseif ... else ... end statement is a recursive tree in Expr, which sometimes is not very convenient to manipulate or analysis, for example, it is not easy to access all the conditions in a long ifelse statement","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex = @expr if x > 100\n    x + 1\nelseif x > 90\n    x + 2\nelseif x > 80\n    x + 3\nelse\n    error(\"some error msg\")\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can find each condition","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex.args[1]\nex.args[3].args[1]\nex.args[3].args[3].args[1]\nex.args[3].args[3].args[3]","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"imagine how would you construct such expression from scratch, or how would you access all the conditions. Thus JLIfElse allows you to access/manipulate ifelse statements directly as a dict-like object","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl = JLIfElse(ex);\njl.map\njl.otherwise","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"you can access to each condition and its action using the condition as your key","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl.map[:(x > 100)]","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"similarly, we can easily construct a JLIfElse","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl = JLIfElse()\njl.map[:(x > 100)] = :(x + 1)\njl.map[:(x > 80)] = :(x + 2)\njl.otherwise = :(error(\"some error msg\"))\njl\nshow_ascii(jl) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"now let's generate back to Expr so that we can give Julia back some executable expression","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"codegen_ast(jl)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can find available syntax types in Syntax Types","category":"page"},{"location":"#Pattern-Matching","page":"Quick Start","title":"Pattern Matching","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Since Expronicon serves as the meta programming stdlib for MLStyle, you can also use the syntax types along with MLStyle, e.g","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using MLStyle\nusing Expronicon\n\nf = @Î» begin\n   JLFunction(;name=:foo, args) => (args, )\n   JLFunction(;name=:boo, args) => (args, )\n   _ => nothing\nend\n\nex_foo = @expr function foo(x::Int, y::T) where {T <: Real}\n    x + y\nend\n\nex_boo = @expr function foo(x::Int)\n    x\nend\nnothing # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"then we can check if our match function gives the right result","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"f(ex_foo)\nf(ex_boo)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can use any syntax types builtin as your expression template to match using MLStyle. If you define your own syntax type, you can also support pattern matching via @syntax_pattern.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"@syntax_pattern","category":"page"},{"location":"#Expronicon.@syntax_pattern","page":"Quick Start","title":"Expronicon.@syntax_pattern","text":"@syntax_pattern <syntax type> <syntax checker>\n\nExample\n\nstruct MyFunction\n    ex :: Expr\n    test_field :: Any\nend\n\nis_xxx(ex::Expr) = Meta.isexpr(ex, :function)\nis_xxx(_) = false\n\njulia> MyFunction(ex::Expr) = MyFunction(ex, :aaa)\njulia> @syntax_pattern(MyFunction, is_xxx)\n\njulia> @match :(function f() end) begin\n        MyFunction(;test_field) => test_field\n    end\n:aaa\n\n\n\n\n\n","category":"macro"},{"location":"#Analysis-Functions","page":"Quick Start","title":"Analysis Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Expronicon provides a lot common analysis functions, you can find the list of them in Analysis. you can use them to check if the expression satisfy certain property, e.g you can check if a given object is a struct definition via is_struct, or check if a given function definition supports keyword arguments via is_kw_function.","category":"page"},{"location":"#Transform-Functions","page":"Quick Start","title":"Transform Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can find the list of them in Transform.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Transform functions usually takes an expression and returns an expression e.g sometimes you only want the name symbol of your function arguments","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def = @expr JLFunction function foo(x::Int, y::Real=2)\nend\nnothing # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def.args\nname_only.(def.args)","category":"page"},{"location":"#Code-Generation-Functions","page":"Quick Start","title":"Code Generation Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"The code generation functions help you generate other target expressions, e.g codegen_ast generates the Julia AST object Expr. All the syntax type can use codegen_ast to generate the corresponding Expr, there are also some other functions start with name codegen in CodeGen you may find useful.","category":"page"},{"location":"#Pretty-Printing","page":"Quick Start","title":"Pretty Printing","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Sometimes, when you define your own intermediate representation, you may want to pretty print your expression with colors and indents. Expronicon also provide some tools for this in Printings.","category":"page"}]
}
