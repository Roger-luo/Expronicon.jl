var documenterSearchIndex = {"docs":
[{"location":"case/#Use-Cases","page":"Case Study","title":"Use Cases","text":"","category":"section"},{"location":"case/#Packages-Using-Expronicon","page":"Case Study","title":"Packages Using Expronicon","text":"","category":"section"},{"location":"case/","page":"Case Study","title":"Case Study","text":"Configurations: Configurations & Options made easy.\nCompilerPluginTools: collective tools for Julia SSA IR.","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Syntax-Types","page":"API Reference","title":"Syntax Types","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Convenient types for storing analysis results of a given Julia Expr, or for creating certain Julia objects easily. These types define some common syntax one would manipulate in Julia meta programming.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"JLFunction\nJLStruct\nJLKwStruct\nJLIfElse\nJLMatch\nJLFor\nJLField\nJLKwField\nNoDefault\nno_default\nJLExpr","category":"page"},{"location":"reference/#Expronicon.JLFunction","page":"API Reference","title":"Expronicon.JLFunction","text":"mutable struct JLFunction <: JLExpr\nJLFunction(;kw...)\n\nType describes a Julia function declaration expression.\n\nFields and Keyword Arguments\n\nAll the following fields are valid as keyword arguments kw in the constructor, and can be access via <object>.<field>.\n\nThe only required keyword argument for the constructor is name, the rest are all optional.\n\nhead: optional, function head, can be :function, :(=) or :(->).\nname: optional, function name, can has type Nothing, Symbol or Expr, default is nothing.\nargs: optional, function arguments, a list of Expr or Symbol.\nkwargs: optional, function keyword arguments, a list of Expr(:kw, name, default).\nrettype: optional, the explicit return type of a function,   can be a Type, Symbol, Expr or just nothing, default is nothing.\nwhereparams: optional, type variables, can be a list of Type,   Expr or nothing, default is nothing.\nbody: optional, function body, an Expr, default is Expr(:block).\nline::LineNumberNode: a LineNumberNode to indicate the line information.\ndoc::String: the docstring of this definition.\n\nExample\n\nConstruct a function expression\n\njulia> JLFunction(;name=:foo, args=[:(x::T)], body= quote 1+1 end, head=:function, whereparams=[:T])\nfunction foo(x::T) where {T}\n    #= REPL[25]:1 =#    \n    1 + 1    \nend\n\nDecompose a function expression\n\njulia> ex = :(function foo(x::T) where {T}\n           #= REPL[25]:1 =#    \n           1 + 1    \n       end)\n:(function foo(x::T) where T\n      #= REPL[26]:1 =#\n      #= REPL[26]:3 =#\n      1 + 1\n  end)\n\njulia> jl = JLFunction(ex)\nfunction foo(x::T) where {T}\n    #= REPL[26]:1 =#    \n    #= REPL[26]:3 =#    \n    1 + 1    \nend\n\nGenerate Expr from JLFunction\n\njulia> codegen_ast(jl)\n:(function foo(x::T) where T\n      #= REPL[26]:1 =#\n      #= REPL[26]:3 =#\n      1 + 1\n  end)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLStruct","page":"API Reference","title":"Expronicon.JLStruct","text":"mutable struct JLStruct <: JLExpr\n\nType describes a Julia struct.\n\nJLStruct(;kw...)\n\nCreate a JLStruct instance.\n\nAvailable Fields and Keyword Arguments\n\nAll the following fields are valid as keyword arguments kw in the constructor, and can be access via <object>.<field>.\n\nThe only required keyword argument for the constructor is name, the rest are all optional.\n\nname::Symbol: name of the struct, this is the only required keyword argument.\nismutable::Bool: if the struct definition is mutable.\ntypevars::Vector{Any}: type variables of the struct, should be Symbol or Expr.\nsupertype: supertype of the struct definition.\nfields::Vector{JLField}: field definitions of the struct, should be a JLField.\nconstructors::Vector{JLFunction}: constructors definitions of the struct, should be JLFunction.\nline::LineNumberNode: a LineNumberNode to indicate the definition position for error report etc.\ndoc::String: documentation string of the struct.\nmisc: other things that happens inside the struct body, by definition this will   just fall through and is equivalent to eval them outside the struct body.\n\nExample\n\nConstruct a Julia struct.\n\njulia> JLStruct(;name=:Foo, typevars=[:T], fields=[JLField(;name=:x, type=Int)])\nstruct Foo{T}\n    x::Int64\nend\n\nDecompose a Julia struct expression\n\njulia> ex = :(struct Foo{T}\n           x::Int64\n       end)\n:(struct Foo{T}\n      #= REPL[31]:2 =#\n      x::Int64\n  end)\n\njulia> jl = JLStruct(ex)\nstruct Foo{T}\n    #= REPL[31]:2 =#\n    x::Int64\nend\n\nGenerate a Julia struct expression\n\njulia> codegen_ast(jl)\n:(struct Foo{T}\n      #= REPL[31]:2 =#\n      x::Int64\n  end)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLKwStruct","page":"API Reference","title":"Expronicon.JLKwStruct","text":"mutable struct JLKwStruct <: JLExpr\nJLKwStruct(;kw...)\n\nType describes a Julia struct that allows keyword definition of defaults. This syntax is similar to JLStruct except the the fields are of type JLKwField.\n\nFields and Keyword Arguments\n\nAll the following fields are valid as keyword arguments kw in the constructor, and can be access via <object>.<field>.\n\nThe only required keyword argument for the constructor is name, the rest are all optional.\n\nname::Symbol: name of the struct, this is the only required keyword argument.\ntypealias::String: an alias of the JLKwStruct,   see also the @option macro in Configurations.jl.\nismutable::Bool: if the struct definition is mutable.\ntypevars::Vector{Any}: type variables of the struct, should be Symbol or Expr.\nsupertype: supertype of the struct definition.\nfields::Vector{JLField}: field definitions of the struct, should be a JLField.\nconstructors::Vector{JLFunction}: constructors definitions of the struct, should be JLFunction.\nline::LineNumberNode: a LineNumberNode to indicate the definition position for error report etc.\ndoc::String: documentation string of the struct.\nmisc: other things that happens inside the struct body, by definition this will   just fall through and is equivalent to eval them outside the struct body.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLIfElse","page":"API Reference","title":"Expronicon.JLIfElse","text":"JLIfElse <: JLExpr\nJLIfElse(;kw...)\n\nJLIfElse describes a Julia if ... elseif ... else ... end expression. It allows one to easily construct such expression by inserting condition and code block via a map.\n\nFields and Keyword Arguments\n\nAll the following fields are valid as keyword arguments kw in the constructor, and can be access via <object>.<field>.\n\nThe only required keyword argument for the constructor is name, the rest are all optional.\n\nconds::Vector{Any}: expression for the conditions.\nstmts::Vector{Any}: expression for the statements for corresponding condition.\notherwise: the else body.\n\nExample\n\nConstruct JLIfElse object\n\nOne can construct an ifelse as following\n\njulia> jl = JLIfElse()\nnothing\n\njulia> jl[:(foo(x))] = :(x = 1 + 1)\n:(x = 1 + 1)\n\njulia> jl[:(goo(x))] = :(y = 1 + 2)\n:(y = 1 + 2)\n\njulia> jl.otherwise = :(error(\"abc\"))\n:(error(\"abc\"))\n\njulia> jl\nif foo(x)\n    x = 1 + 1\nelseif goo(x)\n    y = 1 + 2\nelse\n    error(\"abc\")\nend\n\nGenerate the Julia Expr object\n\nto generate the corresponding Expr object, one can call codegen_ast.\n\njulia> codegen_ast(jl)\n:(if foo(x)\n      x = 1 + 1\n  elseif goo(x)\n      y = 1 + 2\n  else\n      error(\"abc\")\n  end)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLMatch","page":"API Reference","title":"Expronicon.JLMatch","text":"JLMatch <: JLExpr\n\nJLMatch describes a Julia pattern match expression defined by MLStyle. It allows one to construct such expression by simply assign each code block to the corresponding pattern expression.\n\ntip: Tip\nJLMatch is not available in ExproniconLite since it depends on MLStyle's pattern matching functionality.\n\nExample\n\nOne can construct a MLStyle pattern matching expression easily by assigning the corresponding pattern and its result to the map field.\n\njulia> jl = JLMatch(:x)\n#= line 0 =#\nnothing\n\njulia> jl = JLMatch(:x)\n#= line 0 =#\nnothing\n\njulia> jl.map[1] = true\ntrue\n\njulia> jl.map[2] = :(sin(x))\n:(sin(x))\n\njulia> jl\n#= line 0 =#\n@match x begin\n    1 => true\n    2 => sin(x)\n    _ =>     nothing\nend\n\nto generate the corresponding Julia Expr object, one can call codegen_ast.\n\njulia> codegen_ast(jl)\n:(let\n      true\n      var\"##return#263\" = nothing\n      var\"##265\" = x\n      if var\"##265\" isa Int64\n          #= line 0 =#\n          if var\"##265\" === 1\n              var\"##return#263\" = let\n                      true\n                  end\n              #= unused:1 =# @goto var\"####final#264#266\"\n          end\n          #= line 0 =#\n          if var\"##265\" === 2\n              var\"##return#263\" = let\n                      sin(x)\n                  end\n              #= unused:1 =# @goto var\"####final#264#266\"\n          end\n      end\n      #= line 0 =#\n      begin\n          var\"##return#263\" = let\n                  nothing\n              end\n          #= unused:1 =# @goto var\"####final#264#266\"\n      end\n      (error)(\"matching non-exhaustive, at #= line 0 =#\")\n      #= unused:1 =# @label var\"####final#264#266\"\n      var\"##return#263\"\n  end)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLFor","page":"API Reference","title":"Expronicon.JLFor","text":"JLFor <: JLExpr\n\nSyntax type for Julia for loop.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLField","page":"API Reference","title":"Expronicon.JLField","text":"mutable struct JLField <: JLExpr\nJLField(;kw...)\n\nType describes a Julia field in a Julia struct.\n\nFields and Keyword Arguments\n\nAll the following fields are valid as keyword arguments kw in the constructor, and can be access via <object>.<field>.\n\nThe only required keyword argument for the constructor is name, the rest are all optional.\n\nname::Symbol: the name of the field.\ntype: the type of the field.\nisconst: if the field is annotated with const.\nline::LineNumberNode: a LineNumberNode to indicate the line information.\ndoc::String: the docstring of this definition.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.JLKwField","page":"API Reference","title":"Expronicon.JLKwField","text":"mutable struct JLKwField <: JLExpr\n\nType describes a Julia field that can have a default value in a Julia struct.\n\nJLKwField(;kw...)\n\nCreate a JLKwField instance.\n\nFields and Keyword Arguments\n\nAll the following fields are valid as keyword arguments kw in the constructor, and can be access via <object>.<field>.\n\nThe only required keyword argument for the constructor is name, the rest are all optional.\n\nname::Symbol: the name of the field.\ntype: the type of the field.\nisconst: if the field is annotated with const.\ndefault: default value of the field, default is no_default.\nline::LineNumberNode: a LineNumberNode to indicate the line information.\ndoc::String: the docstring of this definition.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.NoDefault","page":"API Reference","title":"Expronicon.NoDefault","text":"NoDefault\n\nType describes a field should have no default value.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Expronicon.no_default","page":"API Reference","title":"Expronicon.no_default","text":"const no_default = NoDefault()\n\nConstant instance for NoDefault that describes a field should have no default value.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Expronicon.JLExpr","page":"API Reference","title":"Expronicon.JLExpr","text":"abstract type JLExpr end\n\nAbstract type for Julia syntax type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Analysis","page":"API Reference","title":"Analysis","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Functions for analysing a given Julia Expr, e.g splitting Julia function/struct definitions etc.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon]\nPages = [\"analysis/analysis.jl\"]","category":"page"},{"location":"reference/#Transform","page":"API Reference","title":"Transform","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Some common transformations for Julia Expr, these functions takes an Expr and returns an Expr.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon]\nPages = [\"transform.jl\"]","category":"page"},{"location":"reference/#Expronicon.alias_gensym-Tuple{Any}","page":"API Reference","title":"Expronicon.alias_gensym","text":"alias_gensym(ex)\n\nReplace gensym with <name>_<id>.\n\nnote: Note\nBorrowed from MacroTools.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.annotations_only-Tuple{Any}","page":"API Reference","title":"Expronicon.annotations_only","text":"annotations_only(ex)\n\nReturn type annotations only. See also name_only.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.eval_interp-Tuple{Module, Any}","page":"API Reference","title":"Expronicon.eval_interp","text":"eval_interp(m::Module, ex)\n\nevaluate the interpolation operator in ex inside given module m.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.eval_literal-Tuple{Module, Any}","page":"API Reference","title":"Expronicon.eval_literal","text":"eval_literal(m::Module, ex)\n\nEvaluate the literal values and insert them back to the expression. The literal value can be checked via is_literal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.expr_map-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Expronicon.expr_map","text":"expr_map(f, c...)\n\nSimilar to Base.map, but expects f to return an expression, and will concanate these expression as a Expr(:block, ...) expression.\n\nExample\n\njulia> expr_map(1:10, 2:11) do i,j\n           :(1 + $i + $j)\n       end\nquote\n    1 + 1 + 2\n    1 + 2 + 3\n    1 + 3 + 4\n    1 + 4 + 5\n    1 + 5 + 6\n    1 + 6 + 7\n    1 + 7 + 8\n    1 + 8 + 9\n    1 + 9 + 10\n    1 + 10 + 11\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.flatten_blocks-Tuple{Any}","page":"API Reference","title":"Expronicon.flatten_blocks","text":"flatten_blocks(ex)\n\nRemove hierachical expression blocks.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.name_only-Tuple{Any}","page":"API Reference","title":"Expronicon.name_only","text":"name_only(ex)\n\nRemove everything else leaving just names, currently supports function calls, type with type variables, subtype operator <: and type annotation ::.\n\nExample\n\njulia> using Expronicon\n\njulia> name_only(:(sin(2)))\n:sin\n\njulia> name_only(:(Foo{Int}))\n:Foo\n\njulia> name_only(:(Foo{Int} <: Real))\n:Foo\n\njulia> name_only(:(x::Int))\n:x\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.nexprs-Tuple{Any, Int64}","page":"API Reference","title":"Expronicon.nexprs","text":"nexprs(f, n::Int)\n\nCreate n similar expressions by evaluating f.\n\nExample\n\njulia> nexprs(5) do k\n           :(1 + $k)\n       end\nquote\n    1 + 1\n    1 + 2\n    1 + 3\n    1 + 4\n    1 + 5\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.prettify-Tuple{Any}","page":"API Reference","title":"Expronicon.prettify","text":"prettify(ex; kw...)\n\nPrettify given expression, remove all LineNumberNode and extra code blocks.\n\nOptions (Kwargs)\n\nAll the options are true by default.\n\nrm_lineinfo: remove LineNumberNode.\nflatten_blocks: flatten begin ... end code blocks.\nrm_nothing: remove nothing in the begin ... end.\npreserve_last_nothing: preserve the last nothing in the begin ... end.\nrm_single_block: remove single begin ... end.\nalias_gensym: replace ##<name>#<num> with <name>_<id>.\nrenumber_gensym: renumber the gensym id.\n\ntips: Tips\nthe LineNumberNode inside macro calls won't be removed since the macrocall expression requires a LineNumberNode. See also issues/#9.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.renumber_gensym-Tuple{Any}","page":"API Reference","title":"Expronicon.renumber_gensym","text":"renumber_gensym(ex)\n\nRe-number gensym with counter from this expression. Produce a deterministic gensym name for testing etc. See also: alias_gensym\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.rm_annotations-Tuple{Any}","page":"API Reference","title":"Expronicon.rm_annotations","text":"rm_annotations(x)\n\nRemove type annotation of given expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.rm_lineinfo-Tuple{Any}","page":"API Reference","title":"Expronicon.rm_lineinfo","text":"rm_lineinfo(ex)\n\nRemove LineNumberNode in a given expression.\n\ntips: Tips\nthe LineNumberNode inside macro calls won't be removed since the macrocall expression requires a LineNumberNode. See also issues/#9.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.rm_nothing-Tuple{Any}","page":"API Reference","title":"Expronicon.rm_nothing","text":"rm_nothing(ex)\n\nRemove the constant value nothing in given expression ex.\n\nKeyword Arguments\n\npreserve_last_nothing: if true, the last nothing   will be preserved.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.subtitute-Tuple{Expr, Pair}","page":"API Reference","title":"Expronicon.subtitute","text":"subtitute(ex::Expr, old=>new)\n\nSubtitute the old symbol old with new.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CodeGen","page":"API Reference","title":"CodeGen","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Code generators, functions that generates Julia Expr from given arguments, Expronicon types. ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon]\nPages = [\"codegen.jl\"]","category":"page"},{"location":"reference/#Expronicon.codegen_ast-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast","text":"codegen_ast(def)\n\nGenerate Julia AST object Expr from a given syntax type.\n\nExample\n\nOne can generate the Julia AST object from a JLKwStruct syntax type.\n\njulia> def = @expr JLKwStruct struct Foo{N, T}\n                  x::T = 1\n              end\n#= kw =# struct Foo{N, T}\n    #= REPL[19]:2 =#\n    x::T = 1\nend\n\njulia> codegen_ast(def)|>rm_lineinfo\nquote\n    struct Foo{N, T}\n        x::T\n    end\n    begin\n        function Foo{N, T}(; x = 1) where {N, T}\n            Foo{N, T}(x)\n        end\n        function Foo{N}(; x::T = 1) where {N, T}\n            Foo{N, T}(x)\n        end\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.codegen_ast_fields-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast_fields","text":"codegen_ast_fields(fields; just_name::Bool=true)\n\nGenerate a list of Julia AST object for each field, only generate a list of field names by default, option just_name can be turned off to call codegen_ast on each field object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.codegen_ast_kwfn","page":"API Reference","title":"Expronicon.codegen_ast_kwfn","text":"codegen_ast_kwfn(def[, name = nothing])\n\nGenerate the keyword function from a Julia struct definition.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, T}\n                  x::T = 1\n              end\n#= kw =# struct Foo{N, T}\n    #= REPL[19]:2 =#\n    x::T = 1\nend\n\njulia> codegen_ast_kwfn(def)|>prettify\nquote\n    function Foo{N, T}(; x = 1) where {N, T}\n        Foo{N, T}(x)\n    end\n    function Foo{N}(; x::T = 1) where {N, T}\n        Foo{N, T}(x)\n    end\nend\n\njulia> def = @expr JLKwStruct struct Foo\n                  x::Int = 1\n              end\n#= kw =# struct Foo\n    #= REPL[23]:2 =#\n    x::Int = 1\nend\n\njulia> codegen_ast_kwfn(def)|>prettify\nquote\n    function Foo(; x = 1)\n        Foo(x)\n    end\n    nothing\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expronicon.codegen_ast_kwfn_infer","page":"API Reference","title":"Expronicon.codegen_ast_kwfn_infer","text":"codegen_ast_kwfn_infer(def, name = nothing)\n\nGenerate the keyword function that infers the type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expronicon.codegen_ast_kwfn_plain","page":"API Reference","title":"Expronicon.codegen_ast_kwfn_plain","text":"codegen_ast_kwfn_plain(def[, name = nothing])\n\nGenerate the plain keyword function that does not infer type variables. So that one can use the type conversions defined by constructors.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Expronicon.codegen_ast_struct-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast_struct","text":"codegen_ast_struct(def)\n\nGenerate pure Julia struct Expr from struct definition. This is equivalent to codegen_ast for JLStruct. See also codegen_ast.\n\nExample\n\njulia> def = JLKwStruct(:(struct Foo\n           x::Int=1\n           \n           Foo(x::Int) = new(x)\n       end))\nstruct Foo\n    x::Int = 1\nend\n\njulia> codegen_ast_struct(def)\n:(struct Foo\n      #= REPL[21]:2 =#\n      x::Int\n      Foo(x::Int) = begin\n              #= REPL[21]:4 =#\n              new(x)\n          end\n  end)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.codegen_ast_struct_body-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast_struct_body","text":"codegen_ast_struct_body(def)\n\nGenerate the struct body.\n\nExample\n\njulia> def = JLStruct(:(struct Foo\n           x::Int\n           \n           Foo(x::Int) = new(x)\n       end))\nstruct Foo\n    x::Int\nend\n\njulia> codegen_ast_struct_body(def)\nquote\n    #= REPL[15]:2 =#\n    x::Int\n    Foo(x::Int) = begin\n            #= REPL[15]:4 =#\n            new(x)\n        end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.codegen_ast_struct_head-Tuple{Any}","page":"API Reference","title":"Expronicon.codegen_ast_struct_head","text":"codegen_ast_struct_head(def)\n\nGenerate the struct head.\n\nExample\n\njulia> using Expronicon\n\njulia> def = JLStruct(:(struct Foo{T} end))\nstruct Foo{T}\nend\n\njulia> codegen_ast_struct_head(def)\n:(Foo{T})\n\njulia> def = JLStruct(:(struct Foo{T} <: AbstractArray end))\nstruct Foo{T} <: AbstractArray\nend\n\njulia> codegen_ast_struct_head(def)\n:(Foo{T} <: AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.struct_name_plain-Tuple{Any}","page":"API Reference","title":"Expronicon.struct_name_plain","text":"struct_name_plain(def)\n\nPlain constructor name. See also struct_name_without_inferable.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, Inferable}\n    x::Inferable = 1\nend\n\njulia> struct_name_plain(def)\n:(Foo{N, Inferable})\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.struct_name_without_inferable-Tuple{Any}","page":"API Reference","title":"Expronicon.struct_name_without_inferable","text":"struct_name_without_inferable(def; leading_inferable::Bool=true)\n\nConstructor name that assume some of the type variables is inferred. See also struct_name_plain. The kwarg leading_inferable can be used to configure whether to preserve the leading inferable type variables, the default is true to be consistent with the default julia constructors.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, Inferable}\n    x::Inferable = 1\nend\n\njulia> struct_name_without_inferable(def)\n:(Foo{N})\n\njulia> def = @expr JLKwStruct struct Foo{Inferable, NotInferable}\n    x::Inferable\nend\n\njulia> struct_name_without_inferable(def; leading_inferable=true)\n:(Foo{Inferable, NotInferable})\n\njulia> struct_name_without_inferable(def; leading_inferable=false)\n:(Foo{NotInferable})\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xcall-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Expronicon.xcall","text":"xcall(name, args...; kw...)\n\nCreate a function call to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xcall-Tuple{Module, Symbol, Vararg{Any}}","page":"API Reference","title":"Expronicon.xcall","text":"xcall(m::Module, name::Symbol, args...; kw...)\n\nCreate a function call to GlobalRef(m, name).\n\ntip: Tip\ndue to Revise/#616, to make your macro work with Revise, we use the dot expression Expr(:., <module>, QuoteNode(<name>)) instead of GlobalRef here.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xfirst-Tuple{Any}","page":"API Reference","title":"Expronicon.xfirst","text":"xfirst(collection)\n\nCreate a function call expression to Base.first.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xgetindex-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Expronicon.xgetindex","text":"xgetindex(collection, key...)\n\nCreate a function call expression to Base.getindex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xiterate-Tuple{Any, Any}","page":"API Reference","title":"Expronicon.xiterate","text":"xiterate(it, st)\n\nCreate a function call expression to Base.iterate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xiterate-Tuple{Any}","page":"API Reference","title":"Expronicon.xiterate","text":"xiterate(it)\n\nCreate a function call expression to Base.iterate.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xlast-Tuple{Any}","page":"API Reference","title":"Expronicon.xlast","text":"xlast(collection)\n\nCreate a function call expression to Base.last.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xmap-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Expronicon.xmap","text":"xmap(f, xs...)\n\nCreate a function call expression to Base.map.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xmapreduce-Tuple{Any, Any, Vararg{Any}}","page":"API Reference","title":"Expronicon.xmapreduce","text":"xmapreduce(f, op, xs...)\n\nCreate a function call expression to Base.mapreduce.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xnamedtuple-Tuple{}","page":"API Reference","title":"Expronicon.xnamedtuple","text":"xnamedtuple(;kw...)\n\nCreate a NamedTuple expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xprint-Tuple","page":"API Reference","title":"Expronicon.xprint","text":"xprint(xs...)\n\nCreate a function call expression to Base.print.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xprintln-Tuple","page":"API Reference","title":"Expronicon.xprintln","text":"xprintln(xs...)\n\nCreate a function call expression to Base.println.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xpush-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"Expronicon.xpush","text":"xpush(collection, items...)\n\nCreate a function call expression to Base.push!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.xtuple-Tuple","page":"API Reference","title":"Expronicon.xtuple","text":"xtuple(xs...)\n\nCreate a Tuple expression.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Printings","page":"API Reference","title":"Printings","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Pretty printing functions.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon]\nPages = [\"printing.jl\"]","category":"page"},{"location":"reference/#Expronicon.print_expr-Tuple{Any}","page":"API Reference","title":"Expronicon.print_expr","text":"print_expr([io::IO], ex)\n\nPrint a given expression. ex can be a Expr or a syntax type JLExpr.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Expronicon.sprint_expr-Tuple{Any}","page":"API Reference","title":"Expronicon.sprint_expr","text":"sprint_expr(ex; context=nothing)\n\nPrint given expression to String, see also print_expr.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Algebra-Data-Type","page":"API Reference","title":"Algebra Data Type","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Algebra data type","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [Expronicon.ADT]\nPages = [\"adt/adt.jl\"]","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using ANSIColoredPrinters\nfunction show_ascii(x)\n    buf = IOBuffer()\n    print(buf, x)\n    HTMLPrinter(buf, root_class=\"terminal-output\")\nend","category":"page"},{"location":"#Expronicon","page":"Quick Start","title":"Expronicon","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Collective tools for metaprogramming on Julia Expr, the meta programming standard library for MLStyle.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Meta programming in general can be decomposed into three steps:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"analyse the given expression\ntransform the given expression to:\nanother target expression\na convenient intermediate representation (IR) that is easy to further manipulate/analyse\ngenerate the target code, the target code can be:\nmost commonly the Julia Expr\nanother language's abstract/concrete syntax tree\na lower-level IR","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"The package Expronicon is thus written to assist you writing meta programs in the above manner.","category":"page"},{"location":"#Builtin-Syntax-Types","page":"Quick Start","title":"Builtin Syntax Types","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"One of the most important tool in Expronicon is the syntax types, these are types describing a specific Julia syntax, e.g JLFunction describes Julia's function definition syntax. The syntax type uses a canonical data structure to represent various syntax that has the same semantic, which is convenient when one wants to manipulate, generate such objects.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"They will allow you to:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"easily analysis a given Julia Expr by converting it to the syntax type\neasily manipulate a given Julia Expr with data structure designed for easier manipulation\neasily generate a Julia Expr using codegen_ast.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Let's take JLFunction as our example again, in Julia, function can be declared in many different ways:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can define a function using the short form","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"f(x) = x","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"or you can declare the same function using the function keyword","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"function f(x)\n    return x\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"If we look at their expression object, we will find they actually have quite different expression structure:","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using Expronicon # hide\nex1 = @expr f(x) = x","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex2 = @expr function f(x)\n    return x\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"here we use a convenient tool to obtain the Julia expression object provided by Expronicon, the @expr macro.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Now if we convert them to the JLFunction type","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl1 = JLFunction(ex1)\nshow_ascii(jl1)# hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl2 = JLFunction(ex2)\nshow_ascii(jl2)# hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can see they have the same structure under the representation of JLFunction.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"dump(jl1)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"dump(jl2)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can easily access to some important information of this function by accessing the fields","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl1.name\njl1.args\njl1.body","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"This is the same for other syntax types, e.g we can get the corresponding syntax type instance of a struct definition","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def = @expr JLStruct struct Foo{T} <: AbstractType\n    x::Int\n    y::T\nend\nshow_ascii(def) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we again use @expr for convenience, however you can also just convert the expression to JLStruct manually","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex = quote\n    struct Foo{T} <: AbstractType\n        x::Int\n        y::T\n    end\nend\ndef = JLStruct(ex.args[2])\nshow_ascii(def) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"once you have the corresponding JLStruct object, you can access many useful information directly","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def.name\ndef.typevars\ndef.supertype\ntypeof(def.fields[1])\ndef.fields[1].name\ndef.fields[1].type","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Some syntax types are defined for easy manipulation such as JLIfElse, Julia's representation of if ... elseif ... else ... end statement is a recursive tree in Expr, which sometimes is not very convenient to manipulate or analysis, for example, it is not easy to access all the conditions in a long ifelse statement","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex = @expr if x > 100\n    x + 1\nelseif x > 90\n    x + 2\nelseif x > 80\n    x + 3\nelse\n    error(\"some error msg\")\nend","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"we can find each condition","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"ex.args[1]\nex.args[3].args[1]\nex.args[3].args[3].args[1]\nex.args[3].args[3].args[3]","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"imagine how would you construct such expression from scratch, or how would you access all the conditions. Thus JLIfElse allows you to access/manipulate ifelse statements directly as a dict-like object","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl = JLIfElse(ex);\njl\njl.otherwise","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"you can access to each condition and its action using the condition as your key","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl[:(x > 100)]","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"similarly, we can easily construct a JLIfElse","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"jl = JLIfElse()\njl[:(x > 100)] = :(x + 1)\njl[:(x > 80)] = :(x + 2)\njl.otherwise = :(error(\"some error msg\"))\njl\nshow_ascii(jl) # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"now let's generate back to Expr so that we can give Julia back some executable expression","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"codegen_ast(jl)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can find available syntax types in Syntax Types","category":"page"},{"location":"#Pattern-Matching","page":"Quick Start","title":"Pattern Matching","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Since Expronicon serves as the meta programming stdlib for MLStyle, you can also use the syntax types along with MLStyle, e.g","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"using MLStyle\nusing Expronicon\n\nf = @Î» begin\n   JLFunction(;name=:foo, args) => (args, )\n   JLFunction(;name=:boo, args) => (args, )\n   _ => nothing\nend\n\nex_foo = @expr function foo(x::Int, y::T) where {T <: Real}\n    x + y\nend\n\nex_boo = @expr function foo(x::Int)\n    x\nend\nnothing # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"then we can check if our match function gives the right result","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"f(ex_foo)\nf(ex_boo)","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can use any syntax types builtin as your expression template to match using MLStyle. If you define your own syntax type, you can also support pattern matching via @syntax_pattern.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"@syntax_pattern","category":"page"},{"location":"#Expronicon.@syntax_pattern","page":"Quick Start","title":"Expronicon.@syntax_pattern","text":"@syntax_pattern <syntax type> <syntax checker>\n\nBundle a syntax type as MLStyle pattern.\n\ntip: Tip\nthis is not available in ExproniconLite since it depends on MLStyle's pattern matching functionality.\n\nExample\n\nstruct MyFunction\n    ex :: Expr\n    test_field :: Any\nend\n\nis_xxx(ex::Expr) = Meta.isexpr(ex, :function)\nis_xxx(_) = false\n\njulia> MyFunction(ex::Expr) = MyFunction(ex, :aaa)\njulia> @syntax_pattern(MyFunction, is_xxx)\n\njulia> @match :(function f() end) begin\n        MyFunction(;test_field) => test_field\n    end\n:aaa\n\n\n\n\n\n","category":"macro"},{"location":"#Analysis-Functions","page":"Quick Start","title":"Analysis Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Expronicon provides a lot common analysis functions, you can find the list of them in Analysis. you can use them to check if the expression satisfy certain property, e.g you can check if a given object is a struct definition via is_struct, or check if a given function definition supports keyword arguments via is_kw_function.","category":"page"},{"location":"#Transform-Functions","page":"Quick Start","title":"Transform Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"You can find the list of them in Transform.","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Transform functions usually takes an expression and returns an expression e.g sometimes you only want the name symbol of your function arguments","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def = @expr JLFunction function foo(x::Int, y::Real=2)\nend\nnothing # hide","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"def.args\nname_only.(def.args)","category":"page"},{"location":"#Code-Generation-Functions","page":"Quick Start","title":"Code Generation Functions","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"The code generation functions help you generate other target expressions, e.g codegen_ast generates the Julia AST object Expr. All the syntax type can use codegen_ast to generate the corresponding Expr, there are also some other functions start with name codegen in CodeGen you may find useful.","category":"page"},{"location":"#Pretty-Printing","page":"Quick Start","title":"Pretty Printing","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Sometimes, when you define your own intermediate representation, you may want to pretty print your expression with colors and indents. Expronicon also provide some tools for this in Printings.","category":"page"},{"location":"#Common-Gotchas","page":"Quick Start","title":"Common Gotchas","text":"","category":"section"},{"location":"","page":"Quick Start","title":"Quick Start","text":"Use & operator inside the pattern if you are referring a specific value, e.g","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"stmt = Expr(:call, GlobalRef(Base, :sin), QuoteNode(1))\n@match stmt begin\n    Expr(:call, GlobalRef(Core, name), args...) => true\n    _ => false\nend # true","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"without &, @match may treat Core as a variable, thus the first pattern matches and return true, which is incorrect, if we add &, we have the expected behaviour","category":"page"},{"location":"","page":"Quick Start","title":"Quick Start","text":"@match stmt begin\n    Expr(:call, GlobalRef(&Core, name), args...) => true\n    _ => false\nend # false","category":"page"}]
}
